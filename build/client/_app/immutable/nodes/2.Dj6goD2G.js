var e=Object.defineProperty,__name=(n,t)=>e(n,"name",{value:t,configurable:!0});import{f as n,a as t}from"../chunks/j718xIQC.js";import"../chunks/DvUICoQe.js";import{p as r,f as o,a,t as s,b as i,c as l,s as c,m as u,d as h,ae as d,r as p}from"../chunks/B65Ra-PH.js";import{e as m,s as f}from"../chunks/dKuiboTu.js";import{s as b}from"../chunks/BJfBD2TX.js";import{s as g}from"../chunks/BhrCqwha.js";import{i as x}from"../chunks/kHfQ76nL.js";const y=""+new URL("../assets/Screenshot3.DxsvaAW-.png",import.meta.url).href,v=""+new URL("../assets/shot4.CAgxQU-n.png",import.meta.url).href,w=""+new URL("../assets/shot5.DZwVWERr.png",import.meta.url).href,k=""+new URL("../assets/shot6.24Ct7-Ci.png",import.meta.url).href;var j=n('<div style="margin-left: 8%; margin-right: 8%" id="top"><h1 class="middle svelte-cxunpl">Recursive Closures</h1> <p>This website explores some of the useful features of m-M(x) closures; i.e., closures created instantiated by statements "m = M(x)", where x can be any value, and the simplest definition of "M" is:</p><pre></pre> <p>A modified version of M can be found at <a href="./cube" class="svelte-cxunpl">Rubik\'s cube example</a>, where M holds an array of function names, making it convenient for players to reverse a series of moves by repeatedly pressing the "Q" key (see <a href="./cube#reverse" class="svelte-cxunpl">function reverse</a>. Another variant of M is demonstrated at <a href="./async5" class="svelte-cxunpl">Synchronous and Asynchronous Functions Handled</a> where the line "x = func(x)" in M (above) is replaced by "x = idP(x).then(v => func(v))", idP(x),and where idP(x) returns a promise holding x.</p> <p>The above definition of M is no more complex than needed to demonstrate the core features of m-M(x) closures. Unless you are sure it is unnecessary, it might be wise to include a try-catch block in the definition of M to handle values of func that are not dF3x, are not functions, or are functions that are incompatible with x. Sometimes, you might even check for functions that change x in a way that makes it incompatible with other necessary functions.</p> <h2 class="svelte-cxunpl">Function Composition</h2> <p>Instead of writing f1(f2(f3(f4(f5(x))))), which can get very messy if the five functions are verbose, you can (A) write m(f1)(f2)(f3)(f4)(f5) where m = M(x) to preserve the modified value of x in the m-M(x) closure for future transformations, for example running m(f6)(f7) at a later time, or for use of the value m(dF3x), for example, console.log("The final result is", m(dF3x)).</p> <p>Alternatively, M(v)(f1)(f2)(f3)(f4)(f5)(dF3x) returns the result of running five functions on some value v, leaving the temporary closure for the garbage collector to delete. This anonymous, and therefore temporary, closure returns 10 after taking the square root of ((3 cubed times 4) minus 8): <span class="or svelte-cxunpl"></span></p> <h2 class="svelte-cxunpl">Isolation of Sequences of Computations</h2> <p>The virtual Rubik\'s cube shown on the <a href="./cube" class="svelte-cxunpl">Rubik\'s cube page</a> demonstrates key presses and button clicks turning the sides, middle sections, or entire body of the virtual Rubik\'s cube that is displayed in browsers. The application code contains two entwined representations of the cube; one written in JavaScript, and the other in HTML.</p> <h2 class="svelte-cxunpl">The Two Representations of the Virtual Cube</h2> <p>The JavaScript representation of the virtual Rubik\'s cube consists of 54 strings contained in an array of six nine-member arrays. This array of arrays is "x" in the application\'s m-M(x) closure. "m" handles events triggered by key presses and mouse clicks. Events that rearrange strings in the m-M(x) closure cause m to operate on one of the functions (let\'s call it "func") defined within the script tags. Pursuant to the definition of M, m(func) rearranges the strings of x, mutating x to func(x).</p> <p>The HTML representation of the cube consists of 54 buttons contained in an array of three nine-member arrays, corresponding to the three sides of the cube which are visible in the browser: front, top, and right. Rotating the virtual cube does not change this fact. For example, clicking the top center square, clicking "Y", and pressing the "Y" key changes x in the m-M(x) closure and also in the DOM, since m(dF3x) is x pursuant to the definition of M.</p> <pre></pre> <p>by x in an m-M(x) closure, where x is an aAny andrray of six nine-member arrays of the strings "blue", "green", "red", "orange", "yellow", and "white". These clicks and key presses call m on functions, causing those functions to operate on the Rubik\'s cube representation in the m-M(x) closure. Rearranging the color strings of x, which are reactive and embedded in the DOM as "background-color = m(dF3x)[j][k]" for j between 0 and 6, and k between 0 and 9, automatically transforms the background colors of the buttons that comprise the Rubik\'s cube representation in the DOM. Rearranging the buttons\'background colors creates the appearance, in the browser, of the virtual Rubik\'s cube, or one of its sides or middle sections, rotating 45 degrees. For example, The top, center square seen in the browser corresponds to this button element in the DOM:</p> <p>The function Yro rearranges the virtual Rubik\'s cube seen in the monitor in a manner corresponding to a 45-degree clockwise rotation of the entire Rubik\'s cube around the vertical axis. It operates on x inside of the m-M(x) closure, insulated from possible interactions with other JavaScript code. The only side effects are changes in the HTML buttons\' background colors.</p> <pre></pre> <p>The illustration below shows the color changes that are seen in browser monitors when the center square on the top of a solved virtual Rubik\'s cube is clicked three times. The color strings of the x array of arrays in the m-M(x) closure rearrange to Yro(x). Overall, three clicks change x to Yro(Yro(Yro(x))). The definition of Yro is in the appendix at the bottom of this page.</p> <img alt="Screenshot3.png" style="width:100px;height:104px;color:#44ff33;" class="svelte-cxunpl"/> <img alt="Screenshot3.png" style="width:100px;height:104px;color:#44ff33;" class="svelte-cxunpl"/> <img alt="Screenshot3.png" style="width:100px;height:104px;color:#44ff33;" class="svelte-cxunpl"/> <img alt="Screenshot3.png" style="width:100px;height:104px;color:#44ff33;" class="svelte-cxunpl"/> <div class="h3 svelte-cxunpl">Cloning With Astonishing Ease</div> <p class="i3 svelte-cxunpl">Cloning is discussed on the <a href="./clone" class="svelte-cxunpl">Clone</a> page. Deeply nested, self-referential, function-containing, complex and complicated objects are cloned with the greatest of ease.</p> <div class="h3 svelte-cxunpl">Modifying M For Special Purposes</div> <p>The definition of M can be modified to avoid mutation (push new results into an array, for example), reverse a series of actions as in the<a href="cube#star" class="svelte-cxunpl">Rubik\'s cube</a> example, handle asynchronous functions, as in <a href="./cube#reverse" class="svelte-cxunpl">the cube reverse function</a>, <a href="./async5#yes" class="svelte-cxunpl">Async</a>, and other purposes.</p> <p>M2, a modified version of M, returns functions that can operate on synchronous and asynchronous, in any order:</p> <pre></pre> <div class="h2 svelte-cxunpl">Efficiently Crunching Numbers</div> <p><a href="./game2" class="svelte-cxunpl">Martingale</a> runs the Martingale betting strategy millions of times, demonstrating that even-odds games of chance are, in the long run, break-even endeavors. Sometimes you end up ahead, sometimes behind. The Martingale strategy doesn\'t change that.</p> <p>to show that it neither increases nor decreases the odds of coming out ahead. x in the m(x)-M closure is [starting amount,1,goal,0] where "starting amount" is the amount of money the player tries to double. "goal is fixed, starting at "starting amount. m operates on the function "f1", which randomly generates 0 or 1 wth equal probability, increasing or decreasing v[1] (the mount of the bet) and v[0] (the players current stake).</p> <p>If you go to <a href="./game2" class="svelte-cxunpl">Martingale</a>, you can try it yourself, learn the betting algorithm, and see the outcomes of tens of thousands of coin flips. m needs only one function, f1, shown below.</p> <pre></pre></div> <a href="#top" class="svelte-cxunpl">Back to the top</a> <br/> <div class="h2 svelte-cxunpl">Appendix</div> <div class="h3 svelte-cxunpl">The Virtual Rubik\'s Cube</div> <p>Additional discussion is at <a href="./cube" class="svelte-cxunpl">Virtual Rubik\'s Cube</a></p> <p>In the m-M(x) representation of a Rubik\'s cube as an array of six nine-member arrays of strings, the solved cube is x = ([ ["blue", "blue", "blue", "blue", "blue", "blue", "blue", "blue", "blue"],\n      ["green", "green", "green", "green", "green", "green", "green", "green", "green"],\n      ["red", "red", "red", "red", "red", "red", "red", "red", "red"],\n      ["orange", "orange", "orange", "orange", "orange", "orange", "orange", "orange", "orange"],\n      ["yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "yellow"],\n      ["white", "white", "white", "white", "white", "white", "white", "white", "white"] ]  The default orientation of the visible sides of a solved cube is yellow on top, blue on the right, and orange facing outward.</p> <p>When m(Yro) executes, Yro constructs an array of six nine-member arrays named "temp," using the 54 strings constituting x in its current state. Finally, pursuant to the definition of M, x = temp, the return value of Yro(x). Here\'s the definition of Yro:</p> <pre></pre> <h1 class="middle2 svelte-cxunpl">Further Discussion of the Fast and Efficient Virtual Rubik\'s Cube</h1> <p>Some of the code responsible for the <a href="./cube" class="svelte-cxunpl">virtual Rubik\'s cube</a> is shown below. Here\'s the HTML code:</p> <pre></pre> <p>A JavaScript representation of a solved virtual Rubik\'s cube is shown below. \'x\' in the m-M(x) closure is an array of six nine-member arrays of strings. x[0] contains nine copies of "blue". The code that determines the colors of the initial right side of the virtual cube displayed in the broswer is shown in the middle block of HTML buttons above. Each of the nine lines specifies background-colors which are elements of x[0], all of which are "blue" when the m-M(x) closure is defined.</p> <pre></pre> <p>After pressing "F", clicking the "F" button, or clicking the upper or lower right side of the front of the virtual cube, x in the m-M(x) closure rearranges to this configuration:</p><pre></pre> <p>And the cube looks like this:</p> <img alt="Right side turned" style="width:150px;height:155px;" class="svelte-cxunpl"/> <p>Here\'s the definition of F:</p> <pre></pre> <p>F populates a temporary array "temp" with values taken from locations on the current configuration of x. It populates temp[0][0], temp[0][3], temp[0][6], with whatever strings happen to be at x[4][2], x[4][5], and x[4][8]. When m(F) returns temp, temp becomes the value of x in the m-M(x) closure.</p> <div class="h3 svelte-cxunpl">Additional Protection of "x" in m-M(x) closures</div> <p>If x is not a primitive value, changing m(dF3x) changes x in the m-M(x) closure. This can be convenient, as in the function "reverse" in <a href="./cube" class="svelte-cxunpl">Rubik\'s Cube</a>. The array "ar" in the modified definition of M holds an array of the names of the functions called when users press keys or click buttons that change the virtual Rubik\'s cube. m(dF3ar) returns ar. "ob" is an object that produces the inverse of the Rubik\'s cube manipulation functions. For example, ob.R is Rz, the inverse of R. Here are the definitions of reverse and ob:</p> <pre></pre> <pre></pre> <p></p> <pre></pre> <p>While not universally effective, this method covers many cases:</p> <pre></pre> <!>',1);function _page(e,n){r(n,!1);var F=__name((()=>{}),"dF3x");function M(e){return __name((function go(n){return n===F?e:(e=n(e),go)}),"go")}__name(M,"M");var O=console.log,C=M(3);function*generatorFunction(){yield"m(dF3x) // 3 (as expected from the definition of M)",yield"m(v=>v**3) . . . causing 3 => 3**3 = 27",yield"m(dF3x) // 27 (as expected)",yield"m(v=>v*2)(v=>v-12) evaluates from left to right; i.e., (2 * 27) - 12.",yield"m(dF3x)  // 42",yield"m(v=>v+7)(Math.sqrt)(dF3x)  // x in the m-M(x) closure is now sqrt(42 + 7) = 7",yield"m(v = v * 6) // Back to 42",yield"m(dF3x)  // 42, as expected",yield"",yield"",yield"",P=generatorFunction()}__name(generatorFunction,"generatorFunction");var P=generatorFunction();function cow(){return null!=P.next().value||generatorFunction(),P}function handleEvent(e){59===e.keyCode&&cow()}__name(cow,"cow"),__name(handleEvent,"handleEvent");var S=__name((()=>{}),"dF3ar");C=M([0,1]);function fib(e,n){for(let t=1;t<=n;t+=1)e((([e,n])=>[n,e+n]));return e(S)}__name(fib,"fib");function M2(e){return e=idP(e),__name((function go(n){return n===F?e:(e=e.then((e=>n(e))),go)}),"go")}O(fib(C,11)),O("Hello","M(3)(v=>v**3)(v=>v*4)(v=>v-8)(Math.sqrt)(dF3x) // 10"),__name(M2,"M2");C=M2(1);var A,z,R,D,J=__name((e=>n=>e+n),"add"),T=__name((e=>n=>e*n),"mult");function wait(e){return new Promise((n=>setTimeout(n,e)))}__name(wait,"wait");var B=u([A,z,R,D]);async function hello(e){return await wait(500),c(B,[A=3,z,R,D]),O(h(B)),await wait(500),c(B,[A,z=2,R,D]),O(h(B)),await wait(500),c(B,[A,z,R=1,D]),O(h(B)),await wait(500),c(B,[A,z,R,D="Blast off"]),O(h(B)),e}__name(hello,"hello");let N=__name((e=>async n=>(await wait(2e3),n*e)),"multP");async function idP(e){return e instanceof Promise?e:Promise.resolve(e)}async function restart(){A="A",z="B",R="C",D="D",hello(),O(A,z,R,D),C(J(6))(N(6))(J(8))(N(2))(Math.sqrt)(F).then((e=>O("m(dF3x) is",e))),C(J(4))(T(3))(F).then((e=>O("m(dF3x) is",e))),C(F).then((e=>O("Confirming that m(dF3x) is",e))),await wait(5e3)}C(F).then((e=>O("m(dF3x resolves to",e))),__name(idP,"idP"),__name(restart,"restart"),restart(),x();var U=j();m("keypress",d,handleEvent);var H=o(U),X=a(l(H),3);X.textContent="    const dF3x = () => {}\n\n    function M (x) {\n      return function go (func)\n        {\n            if (func === dF3x) return x;\n            else x = func(x);\n            return go;\n        }\n    }";var q=a(X,10);a(l(q)).textContent="M(3)(v=>v**3)(v=>v*4)(v=>v-8)(Math.sqrt)(dF3x) // 10",p(q);var Y=a(q,12);Y.textContent='                    <button\n                        style="background-color: {m(dF3x)[4][4]}"\n                        on:click={() => {\n                            m = m(Yro);\n                        }}\n                    /> ';var W=a(Y,6);W.textContent='    <button\n        style="background-color: {m(dF3x)[4][4]}"\n        on:click={() => {\n            m = m(Yro);\n        }}\n    />';var L=a(W,4),E=a(L,2),Q=a(E,2),Z=a(Q,2),K=a(Z,12);K.textContent='    function M2 (x) {\n        x = idP(x);\n        return function go (func){\n            if (func === dF3x) return x;\n            else x = x.then(v => func(v));\n            return go;\n        };\n    };\n    \nvar m = M2(1);\nvar add = a => b => a + b;\nvar mult = a => b => a * b;\nvar div = a => b => a / b;\n\n    function wait(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n\n    async function squareP(x) {\n        await wait(300);\n        return x * x;    \n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n\n    let pause = (t) => async (x) => {\n        await wait(t);\n        return x;\n    };\nvar A,B,C,D;\nvar arr = [A,B,C,D];\n    async function hello(x) {\n        await wait(500);\n        A = 3;\n        arr = [A,B,C,D];\n        log(arr);\n        await wait(500);\n        B = 2;\n        arr = [A,B,C,D];\n        log(arr);\n        await wait(500)\n        C = 1;\n        arr = [A,B,C,D];\n        log(arr);\n        await wait(500);\n        D = "Blast off";\n        arr = [A,B,C,D];\n        log(arr);\n        return x;\n    }\n\n    let addP = (x) => async (y) => {\n        await wait(1000);\n        return x + y;\n    };\n\n    let multP = (a) => async (b) => {\n        await wait(2000);\n        return b * a;\n    };\n\n        m(dF3x).then(v=>log("m(dF3x resolves to", v));\n        \n        async function idP(x) {\n            if (x instanceof Promise) return x;\n            return Promise.resolve(x);\n        }\n\n    async function restart() {\n        A = "A";\n        B = "B";\n        C = "C";\n        D = "D";\n        hello();\n        log(A,B,C,D);\n        m(add(6))(multP(6))(add(8))(multP(2))(Math.sqrt)(dF3x)\n        .then(v => log("m(dF3x) is", v)); // 10\n        m(add(4))(mult(3))(dF3x).then(v => log("m(dF3x) is", v));  // 42\n        m(dF3x).then(v => log("Confirming that m(dF3x) is", v));  // 42\n        await wait(5000);\n    };';var G=a(K);a(G,9).textContent='    import { leftShift } from "mathjs";\n    var log = console.log;\n    var dF3x = () => {};\n\n    function M(x) {\n        return function go(func) {\n            if (func === dF3x) return x;\n            x = func(x);\n            return go;\n        };\n    }\n    var aa = 25;\n    var m = M([aa,1,aa,0]); // x in the m(x)-M closure is [25,1,25,0]\n // The elements of x (above) represent a starting dollars, first bet, goal, and wins.\n\n    function f1 (v) {\n        let result = Math.floor(Math.random()*2);\n        if (result) {           // 1 is true, 0 is false.\n          v[0] += v[1];         // The player gains $1.00\n          log("2<><><><><><><>, m(dF3x) is", m(dF3x));\n          if (v[3] < aa) m(f1)  // Another coin flip, \n          else {\n            log("Double", m(dF3x))\n            return;\n          }  \n        }\n        else {\n            v[0] = v[0] - v[1];\n            v[1] = leftShift(v[1], 1);          \n            log("2******, m(dF3x) is", m(dF3x));\n            if (v[1] > v[0]) {\n              log("Fail", m(dF3x));\n              return\n            }\n            else m(f1);\n        } \n        return v;\n      };',p(H);var V=a(H,16);V.textContent="    var Yro = function Yro(ar) {\n        let temp = [];\n        temp[0] = ar[2];\n        temp[1] = ar[3];\n        temp[2] = ar[1];\n        temp[3] = ar[0];\n        temp[4] = [\n            ar[4][6],\n            ar[4][3],\n            ar[4][0],\n            ar[4][7],\n            ar[4][4],\n            ar[4][1],\n            ar[4][8],\n            ar[4][5],\n            ar[4][2],\n        ];\n        temp[5] = [\n            ar[5][2],\n            ar[5][5],\n            ar[5][8],\n            ar[5][1],\n            ar[5][4],\n            ar[5][7],\n            ar[5][0],\n            ar[5][3],\n            ar[5][6],\n        ];\n        return temp;\n    };";var I=a(V,6);I.textContent='<div class="face front">\n  <div class="grid">\n    <button style="background-color: {m(dF3x)[3][0]}" on:click={() => {m = m(Fz)}}/>\n    <button style="background-color: {m(dF3x)[3][1]}" on:click={() => {m = m(Cx)}}/>\n    <button style="background-color: {m(dF3x)[3][2]}" on:click={() => {m = m(F)}}/>\n    <button style="background-color: {m(dF3x)[3][3]}" on:click={() => {m = m(Cyr)}}/>\n    <button style="background-color: {m(dF3x)[3][4]}" on:click={() => {m = m(Zro)}}/>\n    <button style="background-color: {m(dF3x)[3][5]}" on:click={() => {m = m(Cy)}}/>\n    <button style="background-color: {m(dF3x)[3][6]}" on:click={() => {m = m(Fz)}}/>\n    <button style="background-color: {m(dF3x)[3][7]}" on:click={() => {m = m(Cxr)}}/>\n    <button style="background-color: {m(dF3x)[3][8]}" on:click={() => {m = m(F)}}/>\n  </div>\n</div>\n\n<div class="face right">\n  <div class="grid">\n    <button style="background-color: {m(dF3x)[0][0]}" on:click={() => {m = m(Rz)}}/>\n    <button style="background-color: {m(dF3x)[0][1]}" on:click={() => {m = m(Cz)}}/>\n    <button style="background-color: {m(dF3x)[0][2]}" on:click={() => {m = m(R)}}/>\n    <button style="background-color: {m(dF3x)[0][3]}" on:click={() => {m = m(Cyr)}}/>\n    <button style="background-color: {m(dF3x)[0][4]}" on:click={() => {m = m(Xro)}}/>\n    <button style="background-color: {m(dF3x)[0][5]}" on:click={() => {m = m(Cy)}}/>\n    <button style="background-color: {m(dF3x)[0][6]}" on:click={() => {m = m(Rz)}}/>\n    <button style="background-color: {m(dF3x)[0][7]}" on:click={() => {m = m(Czr)}}/>\n    <button style="background-color: {m(dF3x)[0][8]}" on:click={() => {m = m(R)}}/>\n  </div>\n</div>\n\n<div class="face top">\n  <div class="grid">\n    <button style="background-color: {m(dF3x)[4][0]}" on:click={() => {m = m(Uz)}}/>\n    <button style="background-color: {m(dF3x)[4][1]}" on:click={() => {m = m(Cx)}}/>\n    <button style="background-color: {m(dF3x)[4][2]}" on:click={() => {m = m(U)}}/>\n    <button style="background-color: {m(dF3x)[4][3]}" on:click={() => {m = m(Cz)}}/>\n    <button style="background-color: {m(dF3x)[4][4]}" on:click={() => {m = m(Yro)}}/>\n    <button style="background-color: {m(dF3x)[4][5]}" on:click={() => {m = m(Czr)}}/>\n    <button style="background-color: {m(dF3x)[4][6]}" on:click={() => {m = m(Uz)}}/>\n    <button style="background-color: {m(dF3x)[4][7]}" on:click={() => {m = m(Cxr)}}/>\n    <button style="background-color: {m(dF3x)[4][8]}" on:click={() => {m = m(U)}}/>\n  </div>        \n</div>';var _=a(I,4);_.textContent='      var m = M([ ["blue", "blue", "blue", "blue", "blue", "blue", "blue", "blue", "blue"],\n      ["green", "green", "green", "green", "green", "green", "green", "green", "green"],\n      ["red", "red", "red", "red", "red", "red", "red", "red", "red"],\n      ["orange", "orange", "orange", "orange", "orange", "orange", "orange", "orange", "orange"],\n      ["yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "yellow"],\n      ["white", "white", "white", "white", "white", "white", "white", "white", "white"] ]);';var $=a(_,3);$.textContent='      var m = M([ ["yellow", "blue", "blue", "yellow", "blue", "blue", "yellow", "blue", "blue"],\n      ["green", "green", "white", "green", "green", "white", "green", "green", "white"],\n      ["red", "red", "red", "red", "red", "red", "red", "red", "red"],\n      ["orange", "orange", "orange", "orange", "orange", "orange", "orange", "orange", "orange"],\n      ["yellow", "yellow", "yellow", "yellow", "yellow", "yellow", "green", "green", "green"],\n      ["blue", "blue", "blue", "white", "white", "white", "white", "white", "white"] ]);';var ee=a($,4),ne=a(ee,4);ne.textContent="function F(ar) {\n    let temp = [];\n    temp[0] = [\n      ar[4][6],\n      ar[0][1],\n      ar[0][2],\n      ar[4][7],\n      ar[0][4],\n      ar[0][5],\n      ar[4][8],\n      ar[0][7],\n      ar[0][8],\n    ];\n\n    temp[1] = [\n      ar[1][0],\n      ar[1][1],\n      ar[5][0],\n      ar[1][3],\n      ar[1][4],\n      ar[5][1],\n      ar[1][6],\n      ar[1][7],\n      ar[5][2],\n    ];\n\n    temp[2] = ar[2];\n\n    temp[3] = [\n      ar[3][6],\n      ar[3][3],\n      ar[3][0],\n      ar[3][7],\n      ar[3][4],\n      ar[3][1],\n      ar[3][8],\n      ar[3][5],\n      ar[3][2],\n    ];\n\n    temp[4] = [\n      ar[4][0],\n      ar[4][1],\n      ar[4][2],\n      ar[4][3],\n      ar[4][4],\n      ar[4][5],\n      ar[1][8],\n      ar[1][5],\n      ar[1][2],\n    ];\n\n    temp[5] = [\n      ar[0][6],\n      ar[0][3],\n      ar[0][0],\n      ar[5][3],\n      ar[5][4],\n      ar[5][5],\n      ar[5][6],\n      ar[5][7],\n      ar[5][8],\n    ];\n    return temp;\n} ";var te=a(ne,8);te.textContent="function reverse () { \n    m = m(ob[m(dF3ar).pop()]); // Pops a function name and runs its reverse.   \n    m(dF3ar).pop(); // Discard the inverse functions's name, that m just \n                    // pushed onto ar (inside of the m-M(x) closure). \n  }";var re=a(te,2);re.textContent="const ob = {'R': Rz, 'L': Lz, 'U': Uz, 'D': Dz, 'F': Fz, 'B': Bz, 'Cx': Cxr,\n   'Cy': Cyr, 'Cz': Czr, 'Xro': Xror, 'Yro': Yror, 'Zro': Zror, 'Rz': R,\n   'Lz': L, 'Uz': U, 'Dz': D, 'Fz': F, 'Bz': B, 'Cxr': Cx, 'Cyr': Cy, 'Czr': Cz,\n   'Xror': Xro, 'Yror': Yro, 'Zror': Zro};";var oe=a(re,4);oe.textContent='var log = console.log;\nvar dF3x = () => {};\n\nfunction M(x) {\n    return function go(func) {\n        if (func === dF3x) return x;\n        x = func(x);\n        return go;\n    };\n}\n\nvar m = M({a:1, b:2});\nvar b = m(dF3x);  // b is just another name for x in the m-M(x) closure.\nb.c = 3; \nlog("b is", b);  // b is { a: 1, b: 2, c: 3 }\nlog("m(dF3x) is", m(dF3x));  // m(dF3x) is { a: 1, b: 2, c: 3 }\n// Mutating b mutated x in the m-M(x) closure.\n\nfunction M(x) {\n    return function go(func) {\n        if (func === dF3x) return JSON.parse(JSON.stringify(x));\n        x = func(x);\n        return go;\n    };\n}\n\nvar m = M({a:1, b:2});\nvar b = m(dF3x);  // b is a clone\nb.c = 3;\nlog("b is", b);  // b is { a: 1, b: 2, c: 3 }\nlog("m(dF3x) is", m(dF3x));  // m(dF3x) is { a: 1, b: 2 }\n// x in the m-M(x) closure is not affected by the modification of b.\n\nJSON.parse(JSON.stringify(x)) is unable to make clones of functions, \nundefined values, Symbols, circular references, custom class instances (methods and prototype), dates (converted to strings), regular Expressions (lost), typed Arrays and special objects (converted to plain objects).\n\nJSON.parse(JSON.stringify(x)) is a common technique to create a deep clone of an object in JavaScript. However, it fails to handle certain types of data. Here are the values of x for which this method cannot make a proper clone:\n\n(1) Functions: Functions are not valid JSON data types, so they are omitted during stringification.\n\nconst obj = { fn: function() { return "hello"; } };\nJSON.parse(JSON.stringify(obj)); // { } - the function is lost\n\n(2) Undefined values: undefined is not a valid JSON type, so any property with undefined as a value will be omitted.\n\nconst obj = { key: undefined };\nJSON.parse(JSON.stringify(obj)); // { } - the undefined property is lost\n\n(3) Symbol values: Symbols are not valid in JSON and are excluded during stringification.\n\nconst obj = { key: Symbol("sym") };\nJSON.parse(JSON.stringify(obj)); // { } - the symbol is lost\n\n(4) Circular references: JSON cannot represent circular structures, so attempting to stringify an object with circular references will throw an error.\n\nconst obj = {};\nobj.self = obj;\nJSON.stringify(obj); // Error: Converting circular structure to JSON\n\n(5) Custom class instances: Instances of custom classes will be converted to plain objects, and their methods and prototype chain will be lost.\n\nclass MyClass {\n  constructor() { this.val = 10; }\n  method() { return this.val; }\n}\nconst obj = new MyClass();\nJSON.parse(JSON.stringify(obj)); // { val: 10 } - methods are lost\n\n(6) Date objects: Dates will be serialized as strings and will not retain their Date type.\n\nconst obj = { date: new Date() };\nJSON.parse(JSON.stringify(obj)); // { date: "2024-09-10T00:00:00.000Z" } - Date is converted to string\n\n(7) Regular Expressions: RegExps are not supported and will be converted to empty objects.\n\nconst obj = { regex: /abc/ };\nJSON.parse(JSON.stringify(obj)); // { regex: {} } - Regular expression is lost\n\n(8) Typed Arrays and other special objects: Objects like Map, Set, WeakMap, WeakSet, Int8Array, Uint8Array, etc., will lose their special behavior and be serialized as empty or plain objects.\n\nconst obj = { map: new Map(), set: new Set() };\nJSON.parse(JSON.stringify(obj)); // { map: {}, set: {} } - Map and Set are lost';var ae=a(oe,4);ae.textContent="You can combine Object.create(Object.getPrototypeOf(obj)) \nwith Object.getOwnPropertyDescriptors(obj) to both preserve the prototype and \ncopy the own properties of obj using property descriptors. This approach \nallows you to create a new object with the same prototype as obj, while also \ncopying all its own properties (including non-enumerable properties and \ngetters/setters) in a concise and efficient way.\n\nHow It Works:\n\n    Object.getOwnPropertyDescriptors(obj) returns an object containing \n    all the property descriptors of obj's own properties. Object.create() \n    allows you to specify the prototype for the new object and also pass \n    a property descriptor object as the second argument to define its properties.\n\nHereâ€™s how you can use them together:\n\njavascript\n\nconst newObj = Object.create(\n  Object.getPrototypeOf(obj),   // Set the prototype of the new object\n  Object.getOwnPropertyDescriptors(obj)  // Copy all own properties of 'obj'\n);\n\nExample:\n\njavascript\n\nconst obj = {\n  a: 1,\n  get b() { return this.a + 1; }\n};\n\n// Create a new object with the same prototype and properties as 'obj'\nconst newObj = Object.create(\n  Object.getPrototypeOf(obj), \n  Object.getOwnPropertyDescriptors(obj)\n);\n\nconsole.log(newObj.a);  // Output: 1\nconsole.log(newObj.b);  // Output: 2 (getter works)\nconsole.log(Object.getPrototypeOf(newObj) === Object.getPrototypeOf(obj)); // true\n\nWhy This Is Useful:\n\n    Retains Prototype: You retain the original prototype chain of obj, \n    meaning newObj will inherit methods and properties from the same \n    prototype as obj. Copies Own Properties: The own properties \n    (including getters, setters, and non-enumerable properties) of obj \n    are copied to newObj. Efficient: This is an efficient way to create \n    a new object with the same prototype and properties, without \n    manually copying or assigning them.\n\n    However, deep copying is still not automatic: If any of the properties are objects \n    themselves, they will be shallow copied, and you may need to handle deep \n    copying manually if necessary. Works for non-enumerable properties: This \n    method also copies non-enumerable properties, which Object.assign() would \n    not handle.\n\nExample With Non-enumerable Properties:\n\nconst obj = {};\n\nObject.defineProperty(obj, 'a', {\n  value: 42,\n  enumerable: true,\n  writable: true,\n  configurable: true\n});\n\nObject.defineProperty(obj, 'b', {\n  value: 100,\n  enumerable: false,  // Non-enumerable property\n  writable: true,\n  configurable: true\n});\n\nconst newObj = Object.create(\n  Object.getPrototypeOf(obj),\n  Object.getOwnPropertyDescriptors(obj)\n);\n\nconsole.log(newObj.a);   // Output: 42\nconsole.log(newObj.b);   // Output: 100 (non-enumerable property is copied)\nconsole.log(Object.keys(newObj)); // Output: ['a'], 'b' is non-enumerable";var se=a(ae,2);b(se,n,"default",{}),s((()=>{g(L,"src",y),g(E,"src",v),g(Q,"src",w),g(Z,"src",k),f(G,` ${h(B)??""} `),g(ee,"src","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD8AAABECAMAAAABZB3vAAADAFBMVEX//wCu2+mt2eiQ8JElFhf/pAAlFRYnGBj/pQCQ75Ct2OYqGhj9pQP/pgCblmr8rRSOinT6pQf/qASsmVas1eH6rhfnpB3/qgj2rx6on22nmFs7LSCflWPspRfwpRLVojAxIRmv2eSBgX73pQqsoWv+rA70pQ4tHhqR7JCknG3boipBMyD7+ga2nE34rxvhoySxmlKemm3z8w79/QLt6xSSjGys0tmnwr35+BHRr1DNyj6xpGrLoDq1pWb39h2u0tbw7xM1Jhq/nUX//whoX0SjlVyEg3qqztPf3iOIhnmpyMaVkXOnytD5+Aa6nErlsjn0sCST5o2cynymu6/o5xrx8SDl5jOW7ZI0JSGqp2JLQDOfoXZDODNRSkCkvbawvW7Yr0pSRjDMqEn8/AmNnJeXkGvW1Ss8MCuwz8ylqoa8qGDJyEHfsUG/v0jNr1emw3XssjLa2z2ltqS4tmHFo0fIyE2loGqtv6mnxYTR0UGckWWuq1fAok6NjnlXUkmjrZOZr62x1950akhIOiXT0TWc1YTEnj+xoWjMzlTu7SDkrlDk4yG/vnX2syvCwVOXlm9iX1ns7jCyx7Ha2TSOkoWnz4+6uFe1sE6Ul3+ntpqNiFbVpVa2vlra2SpTRB7d3lHEwj3arUKbrn3wsCmT4IzctklhVDCV2onUsV6c5ZLzsDyj5JfCwluswrKzsFz7/BKsenDfzDi0rnWJgjfNyzbEyl2nj0rGr1/RwnCYp26W3oZLQUDg3hKY1Inv7QaxsmiCeVCdikzDkmCktXjX1kW3o2GEj4admDfGq1fZvFPuuz1tcWiizYOkl2e/wnyevsK1rxeclRiAdhm2xmnNyQ79siF2clyf8JizrjR5bTTdqjlpXh6Qf0l0e3ie2Y5dUj2KhGDDwi2epJDIyrOXwId/c0KtjWqX0oKlol2YfXaXjFm7lVmtsZLVpEjWmzzJmkOBgW2sinnQnV+uvZ/mwVS9oGmZu3evqKDLuZXRwI/6wCXwwzXdw2LFdGujo6Wu2ZH4S2s2AAAIwklEQVRYw52Yd1xUVxbHH883zPCmMMDQBBkYhWEApVdBegdBUTqISBEpSm/SBAGpagQ0ir1XRF00xhgVbNFkd5O1bRKNLRrdTdtskm2fPffNwNxBcNm8P+Yz85n5nnvOPef8zr1DsCd+KPbUHmJimhsv5VLo+S08Zbr92s6vfv+HP/55u7WplKLUqf+L5zae6vcn/AmCsPng/c/unVqabG1kOpk3b/CU7/2dboTyWdybUFnY/5nCGy44o2KGGL9t2XeKC30iHRW0Y0h112LFe/Dmq2sB5xMbrTFviPGu5+8obPLw8Gjqb3dyam/fmTC8DHPGLbesNDb2faU3qrzR/dNuKHDHZQ7r2t9pPS4Qhl4cdhpzhvDJTyj0V7yPRN7sj8d43/331mFr+ccetz/aOtzkkZvblBXi5LBoUUj1xQ3YD4gTlYOJYzxltKYU/xYi713nj1ZjnKk8miAQCo8WOow5Q9ic/HV5ioLn+tbW7L6yzaO/ndm7SEeHnQmVJ/C1YqvDi8+0lubmnm4KWeQT6eDjc/LXhgjF+r77z315967lggNrF67c1uXhkZ//omwHjhNOfQmx/if8Fc7klvYmvPqlgfwkGfHS7e+ujdPQ0LDUQC+Wh3p2C0OvJhXnQtA2o8G8KF6MWVu2ofLV994k+Uk2weZaP1uI6LHH8utzu788cgT5smRbblNIe1b/Tvuj83BvCJ99v9SJaLVUI4Kb+KjnkCWGL/h7UkXcNIWpBQcuVFzpFgYJjw772GDR7HviXW5Gq9XHE9k1rz+uuLX2vb0LLJHzzOJKVzQ0ph261b35aU8F+JJ/Gu2cjY/DohtPSJdjNE3WmxLJt2923vzbv852LKm4deHp093dFUemqUSz0P7Kobi7ceDL3gsoot7q6h+ekLR3DE2rZUiJxtX6LBZH21wXrJyty8iouXLrvQWWWDT2FXFKZzQsj/QkDfwMS0cwPJewXq3NQQ8LrJin12zycr8x3Hrm04VrwcrevQfOJfWobC74c2PElaTJsBiSVruKeH3O2DOjStapra/5p3/8M63t4NBgUlKNsOdI3DQVvGuex3LEb4SXj9QJIzuMt5juZc5iXEFWDl8eGBj4aXDl18qAEE5UMrwrSbqsVyd8f2euyo++Z7G0xc7CocOH2woODhUvWQkpunBg5Q2og9JghlcT1dVShOklTSU/U2cu9okzw1jWyWFc6Tzc1nbwp+ffb0XS1BUBvKurqC4nQJ2QXtLF+RbsE8ckcK4mi3GFw9c21zx8+d8nUfXkIz41dUvOcvCf+/kcJaBlN0uXpcorP7H44suMQJQGo9LZnOMtqgX+WTQL4w3n4Px0lXA4ej+gLnBsdaFpUcbm5aRLijrBXrMH42cbGozjWTi/leHPNNB0TGgqSQYDr/4wjz/2A9582Vt4lpy3+VREpyZtjiDJiGTgz9+21Rrj/WRYNJBO1fVtme2PXCJyTdpY5A01nA18ssTZrlmsZ6HFrG+/R/lz3jieZfuXSMRfjEnaaFbeQIN8UMCHygztBcbTZzdb6YmNhWn8t6zP8A6C8HIzxIN8UASVPNJpsCqvYAUYyXQOkmSKLXiT8CyrPsRnhRaZ0aIYEZIPNkE1pvOZ8jBYte+6LEgicQ6c7Wk1YyaPyb9KOjlW6aBBTi82eZO0qEiE2h946xJFA3P4+nuMJcKWuTIBhDPf08rWzzk8ioOv37aM8OkreyyiaRfgyatc4I0UAsA8nsKhOZrRUWlDXjJBZqZQIrltNZOnXL/N36GvN3YLDXy5GRn2EfBso/lYA4u785hq19fdE+U+AnyQM3hiKw+HJd66uO/4PCeGP0ZG5NxB81elga0EeaPdy9HWTBdKwltm2UM4On5gxPbV8xfHFxNyPtUlZ+MX6sCbqvK7sPyZGIfv02WSA0YyqzJfviyDBnL6EdovuKjuRzOGl+ICYCvA8z9TB/Z/NDkFXuEvB95B4o+UK6ymrgHkC3ju57qT86PtjLZEc9fzy6h+FyG+HpJoJuefGWAdJnCfkJd357dpaHqHHCNh+XqSNluPeHbAKow3fgvP+WsUko+sVLXgnBzQcJAP4KnaERNM8Qrext9keFC+clfgQT6AVz8fFNisKFjgr2ur8Hj98r/1YPiYLa/NXMMY+UB8slAmQxlGPWyVOWI+Kc9L34H406B85LHljHwg/xNXREdHua8osxcE6lQFhT9Q1utMO1XeHfGOfZuARTy0P+KX7uKjAWoQlbZCFgr95wfBjPIq/ccrKUTpc65H8h1MkhnxzPmvUV5yKMUGq0Mlwm5FMDzQPxmWW+ChfByqa8JI0M9gNdcUCtU/ZZ3OxwZoeBrUq1cZI0h2whq8nHkHY4nI/K7iCMR7e9+RsuV8ibbKAGPxtTXRhhh2QzSZnqPBQP0An9vrhsYfXe69yYiSn39xAdCykw9Q+Ya0BEmChFWKYODL64VZ0H+lMD7ooseJo+dv39n6GN+iqZxXelWhLe7XQUqMGREQDw4mxBJEawMaPw+5ozzewFqzZ+ni49B+lTZISV7BSJlAUOX88+NKSMAZUK6I9dKx87/0kjk2gPCMK8YZkpJoJEf/6bCRjx+zq/HUGI83MM/PcM6E4xCyq5n+eod8/JBFiRR2/wh4oHTZDx+gquOUZdKxQc6HBXDx+0uKs6feaJKaZZPyHIuz6Awc2eH9na/K/UeauOYbnRIxSjS/GR+AE/MXN1tTqvcnimu0NODDb+xKrMSBwgfYOB/HD/mgo7Pz0jfvX3BFlCIbj76T4ON83HGiGPFZtdxJ7m8U2zQ++/z6R3aetiZa8myq8h3gv9sp6Vvuf2xKHWJZ8y7MUFsLLRMd+2j8OPbxPMLxXjb1P+6vFMX1bdwPNuymC0PTedhxEPis/VO5f8ttPAxY/4XQT2/sPAC8033plHi5DTY3HqV2tViPUVe9jg3XjKgp82wstVAeejM8cwIbp/b/wbg7tSljwzh8Uwr3N/ByN0ytl9amSN/44r8Gadlq9S3D3QAAAABJRU5ErkJggg==")})),t(e,U),i()}__name(_page,"_page");export{_page as component};
//# sourceMappingURL=2.Dj6goD2G.js.map
