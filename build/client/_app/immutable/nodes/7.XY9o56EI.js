var n=Object.defineProperty;import{f as e,a as o}from"../chunks/j718xIQC.js";import"../chunks/DvUICoQe.js";import{a as t,f as c}from"../chunks/B65Ra-PH.js";var s=e('<h1 class="svelte-1cqu3wk">Simply Cloning Any Object</h1> <h2 class="svelte-1cqu3wk">Even Deeply Nested Data Structures Containing Functions, Self-References, etc</h2> <pre class="svelte-1cqu3wk"></pre> <p>Calling m(func) for some function "func" changes x in the m-M(x) closure to func(x) (unless it throws an error); but  has no effect on x in the m_clone-M(x) closure. Likewise, running m_clone(func) does not affect m. Why? <span style="color:coral">Because x gets reassigned on line 4 of M.</span></p> <h2 class="svelte-1cqu3wk">Two Essential Facts</h2> <p>1. When two variables point to the same object in memory, either variable can modify that object, thereby changing the value of both variables. For example,</p><pre class="svelte-1cqu3wk"></pre> <p>2. When two variables point to the same object in memory, and one gets reassigned <span style="color:coral">(as happens on line 4 of M)</span>, the variables become independent from one another. For example,</p><pre class="svelte-1cqu3wk"></pre> <p>Note: Object.is and === (strict equality) are both used to compare values, but they work differently in two ways: Object.is(NaN, NaN) returns true, whereas NaN === NaN returns false. Object.is(-0, +0) returns true, but -0 === +0 returns false. "===" could have been used in the demonstration below.</p> <pre class="svelte-1cqu3wk"></pre> <p>In the example below, m is defined as an array containing three arrays, one of which contains a function. cl is copy of m. m_clone is a clone of m, m_clone = M(m(dF3x)). The value returned by m_clone(dF3x) is, at first, a reference to the array held in the m-M(x) closure. When m(func) reassigns x in the m-M(x) closure, or m_clone(func) reassigns x in its closure for some function "func", the value of x in the m-M(x) closure and the value of x in the m_clone-M(x) become independent of one another. These reassignment happen on the 4th line of M.</p> <p>As shown in the following examples, changes in m(dF3x) caused by m(v => v.concat(888)) don\'t change m_clone(dF3x), and changing m_clone(dF3x) by running m_clone(v => v.concat(777)) has no effect on m or cl. Unlike m and m_clone, m and cl point to the same place in memory, as do the values held in the m-M(x) and cl-M(x) closures; i.e., m(dF3x) and cl(dF3x). Therefore, changing x in either closure changes x in the other.</p> <p>Here\'s the demonstration code:</p> <pre class="svelte-1cqu3wk"></pre> <br/> <p>This is the text returned by the demonstration code using Node.js:</p> <pre class="svelte-1cqu3wk"></pre>',1);function _page(n){var e=s(),a=t(c(e),4);a.textContent="\n\n  var dF3x = () => {}; // This flag is never called. See line 3 of M, below. \n\n  function M(x) {\n    return function go(func) {\n      if (func === dF3x) return x;\n      else x = func(x);\n      return go;\n    };\n  }\n\n  var m = M(x); // x can be any JavaScript value\n  var m_clone = M(m(dF3x)); ";var l=t(a,7);l.textContent="    var a, b;\n    var a = b = [1,2,3]; \n    a.push(4); \n    console.log(a); // [1,2,3,4];\n    console.log(b); // [1,2,3,4]";var i=t(l,3);i.textContent="    var a, b;\n    a = b = [1,2,3];\n    a = a.concat(4);\n    console.log(a); // [1,2,3,4]\n    console.log(b); // [1,2,3]";var d=t(i,4);d.textContent="        log(Object.is(NaN, NaN)); // true\n        log(NaN === NaN);         // false\n        log(Object.is(-0, 0));    // true\n        log(-0 === 0)             // false ";var r=t(d,8);r.textContent='// Utility function for logging\nvar log = console.log;\n\n// Function used in M (below) to retrieve the \n// current value of x in the closure\nvar dF3x = () => {}\n\n// Function M(x) that creates a closure over any JavaScript value x\nfunction M(x) {\n    return function go(func) {\n        if (func === dF3x) {\n            // If func is dF3x, return the current value of x\n            return x;\n        } else {\n            // **Critical Line**: Reassign x to the result of func(x)\n            x = func(x);\n            return go;\n        }\n    }\n}\n\n// Example function to be stored in the array\nfunction add(a, b) { return a + b; }\n\n// Create closures\nconst m = M([ [6], [7], [add] ]); // Original closure\nconst cl = m;                      // cl references the same closure as m\nconst m_clone = M(m(dF3x));        // m_clone is a new closure with its own x\n\n// **Caption**: Initial State - All closures share the same x\nlog("Initial State:");\nlog("m(dF3x) is", m(dF3x));         // [ [6], [7], [ [Function: add] ] ]\nlog("cl(dF3x) is", cl(dF3x));       // [ [6], [7], [ [Function: add] ] ]\nlog("m_clone(dF3x) is", m_clone(dF3x)); // [ [6], [7], [ [Function: add] ] ]\nlog("Object.is(m(dF3x), cl(dF3x)):", Object.is(m(dF3x), cl(dF3x))); // true\nlog("Object.is(m(dF3x), m_clone(dF3x)):", Object.is(m(dF3x), m_clone(dF3x))); // true\n\n// **Caption**: Mutating x via m_clone before any reassignment\nm_clone(dF3x).push(1111);\nlog("\nAfter m_clone(dF3x).push(1111):");\nlog("m(dF3x) is", m(dF3x));           // Mutated array includes 1111\nlog("cl(dF3x) is", cl(dF3x));         // Also includes 1111\nlog("m_clone(dF3x) is", m_clone(dF3x));   // Includes 1111\nlog("Object.is(m(dF3x), m_clone(dF3x)):", Object.is(m(dF3x), m_clone(dF3x))); // true\n\n// **Caption**: Reassigning x in m - This breaks the shared reference\nm(v => v.concat(888)); // Reassign x in m to a new array\nlog("After m(v => v.concat(888)):");\nlog("m(dF3x) is", m(dF3x));           // New array with 888\nlog("cl(dF3x) is", cl(dF3x));         // Also updated (same closure as m)\nlog("m_clone(dF3x) is", m_clone(dF3x));   // Remains unchanged with 1111\nlog("Object.is(m(dF3x), m_clone(dF3x)):", Object.is(m(dF3x), m_clone(dF3x))); // false\n\n// **Caption**: Reassigning x in m_clone - Independent state\nm_clone(v => v.concat(777)); // Reassign x in m_clone to a new array\nlog("After m_clone(v => v.concat(777)):");\nlog("m(dF3x) is", m(dF3x));           // Unchanged from previous step\nlog("cl(dF3x) is", cl(dF3x));         // Unchanged (same as m)\nlog("m_clone(dF3x) is", m_clone(dF3x));   // New array with 1111 and 777\nlog("Object.is(m(dF3x), m_clone(dF3x)):", Object.is(m(dF3x), m_clone(dF3x))); // false\n\n// **Caption**: Mutating x in m_clone after reassignment\nm_clone(dF3x).push(2222);\nlog("After m_clone(dF3x).push(2222):");\nlog("m(dF3x) is", m(dF3x));           // Unchanged\nlog("cl(dF3x) is", cl(dF3x));         // Unchanged\nlog("m_clone(dF3x) is", m_clone(dF3x));   // Now includes 1111, 777, 2222\n\n// **Caption**: Mutating x in m\nm(dF3x).push(3333);\nlog("After m(dF3x).push(3333):");\nlog("m(dF3x) is", m(dF3x));           // Includes 888, 3333\nlog("cl(dF3x) is", cl(dF3x));         // Also includes 888, 3333\nlog("m_clone(dF3x) is", m_clone(dF3x));   // Unchanged\n\n// Mutating x via m_clone after any reassignment\nm_clone(dF3x).push(444);\nlog("\nAfter m_clone(dF3x).push(444):");\nlog("m(dF3x) is", m(dF3x));           // Does not include 444\nlog("cl(dF3x) is", cl(dF3x));         // Also does not include 444\nlog("m_clone(dF3x) is", m_clone(dF3x));   // Only the clone has been updated\nlog("Object.is(m(dF3x), m_clone(dF3x)):", Object.is(m(dF3x), m_clone(dF3x))); // Now it\'s false',t(r,6).textContent="Initial State:\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ] ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ] ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ] ]\nObject.is(m(dF3x), cl(dF3x)): true\nObject.is(m(dF3x), m_clone(dF3x)): true\n\nAfter m_clone(dF3x).push(1111):\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111 ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111 ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111 ]\nObject.is(m(dF3x), m_clone(dF3x)): true\n\nAfter m(v => v.concat(888)):\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888 ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888 ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111 ]\nObject.is(m(dF3x), m_clone(dF3x)): false\n\nAfter m_clone(v => v.concat(777)):\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888 ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888 ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 777 ]\nObject.is(m(dF3x), m_clone(dF3x)): false\n\nAfter m_clone(dF3x).push(2222):\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888 ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888 ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 777, 2222 ]\n\nAfter m(dF3x).push(3333):\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888, 3333 ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888, 3333 ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 777, 2222 ]\n\nAfter m_clone(dF3x).push(444):\nm(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888, 3333 ]\ncl(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 888, 3333 ]\nm_clone(dF3x) is [ [ 6 ], [ 7 ], [ [Function: add] ], 1111, 777, 2222, 444 ]\nObject.is(m(dF3x), m_clone(dF3x)): false ",o(n,e)}n(_page,"name",{value:"_page",configurable:!0});export{_page as component};
//# sourceMappingURL=7.XY9o56EI.js.map
