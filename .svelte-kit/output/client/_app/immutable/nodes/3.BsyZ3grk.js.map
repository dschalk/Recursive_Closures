{"version":3,"file":"3.BsyZ3grk.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/input.js","../../../../../../src/routes/Collatz/+page.svelte"],"sourcesContent":["import { DEV } from 'esm-env';\nimport { render_effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport * as e from '../../../errors.js';\nimport { is } from '../../../proxy.js';\nimport { queue_micro_task } from '../../task.js';\nimport { hydrating } from '../../hydration.js';\nimport { untrack } from '../../../runtime.js';\nimport { is_runes } from '../../../context.js';\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_value(input, get, set = get) {\n\tvar runes = is_runes();\n\n\tlisten_to_event_and_reset_event(input, 'input', (is_reset) => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\t/** @type {any} */\n\t\tvar value = is_reset ? input.defaultValue : input.value;\n\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\tset(value);\n\n\t\t// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,\n\t\t// because we use mutable state which ensures the render effect always runs)\n\t\tif (runes && value !== (value = get())) {\n\t\t\tvar start = input.selectionStart;\n\t\t\tvar end = input.selectionEnd;\n\n\t\t\t// the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\n\t\t\t// Restore selection\n\t\t\tif (end !== null) {\n\t\t\t\tinput.selectionStart = start;\n\t\t\t\tinput.selectionEnd = Math.min(end, input.value.length);\n\t\t\t}\n\t\t}\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\t(hydrating && input.defaultValue !== input.value) ||\n\t\t// If defaultValue is set, then value == defaultValue\n\t\t// TODO Svelte 6: remove input.value check and set to empty string?\n\t\t(untrack(get) == null && input.value)\n\t) {\n\t\tset(is_numberlike_input(input) ? to_number(input.value) : input.value);\n\t}\n\n\trender_effect(() => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\tvar value = get();\n\n\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)\n\t\t\treturn;\n\t\t}\n\n\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)\n\t\t\t// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)\n\t\t\treturn;\n\t\t}\n\n\t\t// don't set the value of the input if it's the same to allow\n\t\t// minlength to work properly\n\t\tif (value !== input.value) {\n\t\t\t// @ts-expect-error the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\t\t}\n\t});\n}\n\n/** @type {Set<HTMLInputElement[]>} */\nconst pending = new Set();\n\n/**\n * @param {HTMLInputElement[]} inputs\n * @param {null | [number]} group_index\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_group(inputs, group_index, input, get, set = get) {\n\tvar is_checkbox = input.getAttribute('type') === 'checkbox';\n\tvar binding_group = inputs;\n\n\t// needs to be let or related code isn't treeshaken out if it's always false\n\tlet hydration_mismatch = false;\n\n\tif (group_index !== null) {\n\t\tfor (var index of group_index) {\n\t\t\t// @ts-expect-error\n\t\t\tbinding_group = binding_group[index] ??= [];\n\t\t}\n\t}\n\n\tbinding_group.push(input);\n\n\tlisten_to_event_and_reset_event(\n\t\tinput,\n\t\t'change',\n\t\t() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = input.__value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t}\n\n\t\t\tset(value);\n\t\t},\n\t\t// TODO better default value handling\n\t\t() => set(is_checkbox ? [] : null)\n\t);\n\n\trender_effect(() => {\n\t\tvar value = get();\n\n\t\t// If we are hydrating and the value has since changed, then use the update value\n\t\t// from the input instead.\n\t\tif (hydrating && input.defaultChecked !== input.checked) {\n\t\t\thydration_mismatch = true;\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_checkbox) {\n\t\t\tvalue = value || [];\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = value.includes(input.__value);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = is(input.__value, value);\n\t\t}\n\t});\n\n\tteardown(() => {\n\t\tvar index = binding_group.indexOf(input);\n\n\t\tif (index !== -1) {\n\t\t\tbinding_group.splice(index, 1);\n\t\t}\n\t});\n\n\tif (!pending.has(binding_group)) {\n\t\tpending.add(binding_group);\n\n\t\tqueue_micro_task(() => {\n\t\t\t// necessary to maintain binding group order in all insertion scenarios\n\t\t\tbinding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1));\n\t\t\tpending.delete(binding_group);\n\t\t});\n\t}\n\n\tqueue_micro_task(() => {\n\t\tif (hydration_mismatch) {\n\t\t\tvar value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t} else {\n\t\t\t\tvar hydration_input = binding_group.find((input) => input.checked);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = hydration_input?.__value;\n\t\t\t}\n\n\t\t\tset(value);\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_checked(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', (is_reset) => {\n\t\tvar value = is_reset ? input.defaultChecked : input.checked;\n\t\tset(value);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the update value from the input instead.\n\t\t(hydrating && input.defaultChecked !== input.checked) ||\n\t\t// If defaultChecked is set, then checked == defaultChecked\n\t\tuntrack(get) == null\n\t) {\n\t\tset(input.checked);\n\t}\n\n\trender_effect(() => {\n\t\tvar value = get();\n\t\tinput.checked = Boolean(value);\n\t});\n}\n\n/**\n * @template V\n * @param {Array<HTMLInputElement>} group\n * @param {V} __value\n * @param {boolean} checked\n * @returns {V[]}\n */\nfunction get_binding_group_value(group, __value, checked) {\n\tvar value = new Set();\n\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) {\n\t\t\t// @ts-ignore\n\t\t\tvalue.add(group[i].__value);\n\t\t}\n\t}\n\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => FileList | null} get\n * @param {(value: FileList | null) => void} set\n */\nexport function bind_files(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', () => {\n\t\tset(input.files);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\thydrating &&\n\t\tinput.files\n\t) {\n\t\tset(input.files);\n\t}\n\n\trender_effect(() => {\n\t\tinput.files = get();\n\t});\n}\n","\n\n<script>\n\nvar conjecture = `For any positive integer n, the Collatz sequence is defined as follows:\n\n    If n is even:\n        Divide it by 2.\n    If n is odd:\n        Multiply it by 3 and add 1.\n\n    Repeat the process with the new value of n.\n\nThe conjecture states that no matter what positive integer you start with, the sequence will always eventually reach 1.`;\n\nvar example = `    6 is even,  6÷2=3\n    3 is odd,   3×3+1=10\n    10 is even, 10÷2=5\n    5 is odd,   5×3+1=16.\n    16 is even, 16÷2=8.\n    8 is even,  8÷2=4.\n    4 is even,  4÷2=2.\n    2 is even,  2÷2=1.`\n\nvar code = `  var log = console.log;\n  var dF3x = () => {};\n\n  function M(x) {\n    return function go(func) {\n      if (func === dF3x) return x;\n      else x = func(x);\n      return go;\n    };\n  }\n\nvar n;\nvar m;\n\nvar collatz = function collatz (n) {\n    m = M([n, 0]);\n    m(f);\n}\nvar out = \"\";\n\nfunction f (d) {\n      if (d[1] === 0) log(\"testing the number\", d[0]);\n      d[1] = d[1] += 1;\n      if (d[0] % 2 === 0) d = [d[0]/2, d[1]]\n      else if (d[0] % 2 !== 0) d = [d[0]*3 + 1, d[1]]\n      if (d[0] !== 1) f(d)\n      else {\n          d[1] = d[1];\n          out = \"The number of steps was \" + d[1];\n      }\n}\n\nfunction getInput (event) {\n    n = event.target.value;\n}`;\n\nvar results = `testing the number 10\nThe number of steps is 6\n\ntesting the number 100\nThe number of steps is 25\n\ntesting the number 1000\nThe number of steps is 111\n\ntesting the number 10000\nThe number of steps is 29\n\ntesting the number 100000\nThe number of steps is 128\n\ntesting the number 1000000\nThe number of steps is 152\n\ntesting the number 10000000\nThe number of steps is 145\n\ntesting the number 100000000\nThe number of steps is 107\n\ntesting the number 1000000000\nThe number of steps is 100\n\ntesting the number 10000000000\nThe number of steps is 124\n\ntesting the number 100000000000\nThe number of steps is 347\n\ntesting the number 1000000000000\nThe number of steps is 146`\n\nvar bigNum = `testing the number 2.6561398887587478e+95\nd is [ 1.3280699443793739e+95, 1 ]\nd is [ 6.6403497218968695e+94, 2 ]\nd is [ 3.3201748609484348e+94, 3 ]\nd is [ 1.6600874304742174e+94, 4 ]\nd is [ 8.300437152371087e+93, 5 ]\nd is [ 4.1502185761855434e+93, 6 ]\nd is [ 2.0751092880927717e+93, 7 ]\nd is [ 1.0375546440463859e+93, 8 ]\nd is [ 5.1877732202319293e+92, 9 ]\nd is [ 2.5938866101159647e+92, 10 ]\nd is [ 1.2969433050579823e+92, 11 ]\n...\nd is [ 1364, 578 ]\nd is [ 682, 579 ]\nd is [ 341, 580 ]\nd is [ 1024, 581 ]\nd is [ 512, 582 ]\nd is [ 256, 583 ]\nd is [ 128, 584 ]\nd is [ 64, 585 ]\nd is [ 32, 586 ]\nd is [ 16, 587 ]\nd is [ 8, 588 ]\nd is [ 4, 589 ]\nd is [ 2, 590 ]\nd is [ 1, 591 ]\nThe number of steps is 591`;\n\nvar biggerNumber  = `testing the number 1.7190733398152932e+304\nd is [ 8.595366699076466e+303, 1 ]\nd is [ 4.297683349538233e+303, 2 ]\nd is [ 2.1488416747691165e+303, 3 ]\nd is [ 1.0744208373845582e+303, 4 ]\nd is [ 5.372104186922791e+302, 5 ]\nd is [ 2.6860520934613956e+302, 6 ]\n...\nd is [ 53, 1204 ]\nd is [ 160, 1205 ]\nd is [ 80, 1206 ]\nd is [ 40, 1207 ]\nd is [ 20, 1208 ]\nd is [ 10, 1209 ]\nd is [ 5, 1210 ]\nd is [ 16, 1211 ]\nd is [ 8, 1212 ]\nd is [ 4, 1213 ]\nd is [ 2, 1214 ]\nd is [ 1, 1215 ]\nThe number of steps is 1215`;\n\nvar big = `\np@p:~/monad/Useful-Recursive-Closures-in-JavaScript/src/routes$ node test2\ntesting the number 1.2247208276643356e+201\nd is [ 6.123604138321678e+200, 1 ]\nd is [ 3.061802069160839e+200, 2 ]\nd is [ 1.5309010345804195e+200, 3 ]\nd is [ 7.654505172902098e+199, 4 ]\n...\nd is [ 2.3611832414348226e+21, 597 ]\nd is [ 1.1805916207174113e+21, 598 ]\nd is [ 590295810358705700000, 599 ]\nd is [ 295147905179352830000, 600 ]\nd is [ 147573952589676410000, 601 ]\nd is [ 73786976294838210000, 602 ]\nd is [ 36893488147419103000, 603 ]\nd is [ 18446744073709552000, 604 ]\nd is [ 9223372036854776000, 605 ]\nd is [ 4611686018427388000, 606 ]\nd is [ 2305843009213694000, 607 ]\nd is [ 1152921504606847000, 608 ]\nd is [ 576460752303423500, 609 ]\nd is [ 288230376151711740, 610 ]\nd is [ 144115188075855870, 611 ]\nd is [ 72057594037927940, 612 ]\nd is [ 36028797018963970, 613 ]\nd is [ 18014398509481984, 614 ]\nd is [ 9007199254740992, 615 ]\nd is [ 4503599627370496, 616 ]\nd is [ 2251799813685248, 617 ]\nd is [ 1125899906842624, 618 ]\nd is [ 562949953421312, 619 ]\nd is [ 281474976710656, 620 ]\nd is [ 140737488355328, 621 ]\nd is [ 70368744177664, 622 ]\nd is [ 35184372088832, 623 ]\nd is [ 17592186044416, 624 ]\nd is [ 8796093022208, 625 ]\nd is [ 4398046511104, 626 ]\nd is [ 2199023255552, 627 ]\nd is [ 1099511627776, 628 ]\nd is [ 549755813888, 629 ]\nd is [ 274877906944, 630 ]\nd is [ 137438953472, 631 ]\nd is [ 68719476736, 632 ]\nd is [ 34359738368, 633 ]\nd is [ 17179869184, 634 ]\nd is [ 8589934592, 635 ]\nd is [ 4294967296, 636 ]\nd is [ 2147483648, 637 ]\nd is [ 1073741824, 638 ]\nd is [ 536870912, 639 ]\nd is [ 268435456, 640 ]\nd is [ 134217728, 641 ]\nd is [ 67108864, 642 ]\nd is [ 33554432, 643 ]\nd is [ 16777216, 644 ]\nd is [ 8388608, 645 ]\nd is [ 4194304, 646 ]\nd is [ 2097152, 647 ]\nd is [ 1048576, 648 ]\nd is [ 524288, 649 ]\nd is [ 262144, 650 ]\nd is [ 131072, 651 ]\nd is [ 65536, 652 ]\nd is [ 32768, 653 ]\nd is [ 16384, 654 ]\nd is [ 8192, 655 ]\nd is [ 4096, 656 ]\nd is [ 2048, 657 ]\nd is [ 1024, 658 ]\nd is [ 512, 659 ]\nd is [ 256, 660 ]\nd is [ 128, 661 ]\nd is [ 64, 662 ]\nd is [ 32, 663 ]\nd is [ 16, 664 ]\nd is [ 8, 665 ]\nd is [ 4, 666 ]\nd is [ 2, 667 ]\nd is [ 1, 668 ]\nThe number of steps is 668\n`\n\n  var log = console.log;\n  var dF3x = () => {};\n\n  function M(x) {\n    return function go(func) {\n      if (func === dF3x) return x;\n      else x = func(x);\n      return go;\n    };\n  }\n\nvar n;\nvar m;\n\nvar collatz = function collatz (n) {\n    m = M([n, 0]);\n    m(f);\n}\nvar out = \"\";\n\nfunction f (d) {\n      if (d[1] === 0) log(\"testing the number\", d[0]);\n      d[1] = d[1] += 1;\n      if (d[0] % 2 === 0) d = [d[0]/2, d[1]]\n      else if (d[0] % 2 !== 0) d = [d[0]*3 + 1, d[1]]\n      if (d[0] !== 1) f(d)\n      else {\n          d[1] = d[1];\n          out = \"The number of steps was \" + d[1];\n      }\n}\n\nfunction getInput (event) {\n    n = event.target.value;\n}\n</script>\n\n<h1>The Collatz Conjecture</h1>\n<pre>{conjecture}</pre>\n<p> For example, consider n = 6:</p>\n<pre>{example}</pre>\n<br>\n<div>*******************************************************</div>\n<div>*******************************************************</div>\n<p> Enter an integer greater than 1 below to see how many steps it takes to get to the the number \"1\". The arrow keys work. For example, if you enter 32, you get 5; press the \"down\" arrow on your keyboard, or the \"down\" arrow on the input box (below), and see that it takes 106 steps for 31 to get to 1. </p>\n<input type=\"number\" bind:value={n} on:keypress = {() => collatz(n)} on:change = {() => collatz(n)} on:input = {() => collatz(n)} on:change = {() => n = n} on:keypress = {() => n = n}    />\n<h3>The selected number is {n}</h3>\n<h3>{out}</h3>\n<div>*******************************************************</div>\n<div>*******************************************************</div>\n\n<!-- <button on:click = {() => collatz(n)}>Run collatz</button> -->\n\n<p> Here's the code that generates the Collatz sequence on this page:</p>\n<pre>{code}</pre>\n<p> Here are some results:</p>\n<pre>{results}</pre>\n<p> Even n = 9**100 finishes in fewer than 1000 steps, as shown below. </p>\n<pre>{bigNum}</pre>\n\n\n\n\n\n<br><br><br>\n<br><br><br>\n\n\n\n<style>\n    h1 {text-align: center}\n    h2 {text-align: center}\n    pre {\n        font-size: 20px;\n        white-space: pre-wrap;       /* Since CSS 2.1 */\n        word-break: keep-all;\n    }\n  input[type=number] {\n      font-size: 34px;\n      width: 80%;\n      background-color: lightblue\n  }\n</style>"],"names":["bind_value","input","get","set","runes","is_runes","listen_to_event_and_reset_event","is_reset","value","defaultValue","is_numberlike_input","to_number","start","selectionStart","end","selectionEnd","Math","min","length","hydrating","untrack","render_effect","type","__name","log","console","dF3x","M","x","go","func","n","$.mutable_source","collatz","m","f","out","d","$.set","$.safe_get","$$value","$.event","event"],"mappings":"qXAgBO,SAASA,WAAWC,EAAOC,EAAKC,EAAMD,GAC5C,IAAIE,EAAQC,IAEoBC,EAAAL,EAAO,SAAUM,IAOhD,IAAIC,EAAQD,EAAWN,EAAMQ,aAAeR,EAAMO,MAMlD,GALAA,EAAQE,oBAAoBT,GAASU,UAAUH,GAASA,EACxDL,EAAIK,GAIAJ,GAASI,KAAWA,EAAQN,KAAQ,CACvC,IAAIU,EAAQX,EAAMY,eACdC,EAAMb,EAAMc,aAGhBd,EAAMO,MAAQA,GAAS,GAGX,OAARM,IACHb,EAAMY,eAAiBD,EACvBX,EAAMc,aAAeC,KAAKC,IAAIH,EAAKb,EAAMO,MAAMU,QAEnD,MAMGC,GAAalB,EAAMQ,eAAiBR,EAAMO,OAG1B,MAAhBY,EAAQlB,IAAgBD,EAAMO,QAE/BL,EAAIO,oBAAoBT,GAASU,UAAUV,EAAMO,OAASP,EAAMO,OAGjEa,GAAc,KAMb,IAAIb,EAAQN,IAERQ,oBAAoBT,IAAUO,IAAUG,UAAUV,EAAMO,SAKzC,SAAfP,EAAMqB,MAAoBd,GAAUP,EAAMO,QAQ1CA,IAAUP,EAAMO,QAEnBP,EAAMO,MAAQA,GAAS,MAG1B,CA4JA,SAASE,oBAAoBT,GAC5B,IAAIqB,EAAOrB,EAAMqB,KACV,MAAS,WAATA,GAA8B,UAATA,CAC7B,CAKA,SAASX,UAAUH,GACX,MAAU,KAAVA,EAAe,MAAQA,CAC/B,CA1OgBe,OAAAvB,WAAA,cAgOPuB,OAAAb,oBAAA,uBAQAa,OAAAZ,UAAA,8oCClBHa,EAAMC,QAAQD,IACdE,EAAaH,QAAA,QAAT,iBAECI,EAAEC,2BACOC,GAAGC,GACb,OAAAA,IAASJ,EAAaE,GACrBA,EAAIE,EAAKF,GACPC,GACR,QACH,CANSN,OAAAI,EAAA,SAQPI,EAACC,IAGDC,EAAmBA,QAAAA,SAAAA,SAASF,GACxBJ,EAAG,CAAAI,EAAG,GACVG,CAAEC,EACN,GAHuB,WAInBC,IAAM,aAEDD,EAAGE,GACO,IAATA,EAAE,MAAc,qBAAsBA,EAAE,IAC5CA,EAAE,GAAKA,EAAE,IAAM,EACXA,EAAE,GAAK,GAAM,EAAGA,EAAK,CAAAA,EAAE,GAAG,EAAGA,EAAE,IAC1BA,EAAE,GAAK,GAAM,IAAQA,EAAA,CAAK,EAALA,EAAE,GAAO,EAAGA,EAAE,KAC/B,IAATA,EAAE,KAAYA,IAEZA,EAAA,GAAKA,EAAE,GACTC,EAAAF,EAAM,2BAA6BC,EAAE,IAE/C,CAVSd,OAAAY,EAAA,m3FA0BmBJ,IAAC,YACxBK,OAF4BpC,WAAAC,GAAA,IAAAsC,EAAAR,UAAAA,EAACS,KAAuBC,EAAA,WAAAxC,GAAA,IAAAgC,IAAQF,MAAuBU,EAAA,SAAAxC,GAAA,IAAAgC,IAAQF,MAAsBU,EAAA,QAAAxC,GAAA,IAAAgC,IAAQF,MAAuBW,EAAA,SAAAzC,GAAA,IAAAqC,EAAAP,IAAIA,MAAwBW,EAAA,WAAAzC,GAAA,IAAAqC,EAAAP,IAAIA","x_google_ignoreList":[0]}