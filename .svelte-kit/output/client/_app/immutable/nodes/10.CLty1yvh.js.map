{"version":3,"file":"10.CLty1yvh.js","sources":["../../../../../../src/routes/digitalannealing/+page.svelte"],"sourcesContent":["\n<script>\n  // Initial state\n  var A = {\n    cities: [],\n    bestPath: [],\n    penultimatePath: [],\n    beforeDistance: 0,\n    afterDistance: 0,\n    improved: true,\n    step: 0,\n    lastChange: { start: -1, end: -1 }\n  };\n\n  import { onMount } from 'svelte';\n  const dF3x = Symbol('dF3x');\n\n  const M = (initialState) => {\n    let x = { ...initialState };\n    const go = (func) => {\n      if (func === dF3x) {\n        return x;\n      }\n      x = func(x);\n      return go;\n    };\n    return go;\n  };\n\n  // Update m initialization too\n  var m = M({\n    cities: [],\n    bestPath: [],\n    penultimatePath: [],\n    beforeDistance: 0,\n    afterDistance: 0,\n    improved: true,\n    step: 0,\n    lastChange: { start: -1, end: -1 }\n  });\n\n  let beforeCanvas;\n  let afterCanvas;\n\n  const generateCities = () => {\n    const newCities = Array.from({ length: 50 }, () => ({\n      x: Math.random() * 800,\n      y: Math.random() * 600,\n    }));\n\n    const newPath = Array.from({ length: newCities.length }, (_, i) => i);\n    const initialDistance = pathDistance(newPath, newCities);\n\n    m(v => ({\n      cities: newCities,\n      bestPath: newPath,\n      penultimatePath: newPath,\n      beforeDistance: initialDistance,\n      afterDistance: initialDistance,\n      improved: true,\n      step: 0,\n      lastChange: { start: -1, end: -1 }\n    }));\n    A = m(dF3x);\n    drawBefore(A.penultimatePath, A.lastChange);\n    drawAfter(A.cities, A.bestPath, A.lastChange);\n  };\n\n  const solveTSP = (m) => {\n    m((state) => {\n      if (!state.improved) return state;\n\n      const { bestPath, cities } = state;\n      const currentDistance = pathDistance(bestPath, cities);\n\n      for (let i = 1; i < bestPath.length - 1; i++) {\n        for (let j = i + 1; j < bestPath.length; j++) {\n          const newPath = [...bestPath];\n          const segment = newPath.slice(i, j + 1).reverse();\n          newPath.splice(i, segment.length, ...segment);\n\n          const newDistance = pathDistance(newPath, cities);\n          if (newDistance < currentDistance) {\n            return {\n              ...state,\n              bestPath: newPath,\n              penultimatePath: bestPath,\n              afterDistance: newDistance,\n              improved: true,\n              step: state.step + 1,\n              lastChange: { start: i, end: j },\n            };\n          }\n        }\n      }\n\n      return { ...state, improved: false, lastChange: { start: -1, end: -1 } };\n    });\n\n    A = m(dF3x);\n    console.log('Current state:', A);\n    drawBefore(A.penultimatePath, A.lastChange);\n    drawAfter(A.cities, A.bestPath, A.lastChange);\n  };\n\n  function pathDistance(path, cities) {\n    if (!path || !cities || path.length < 2 || cities.length < 2) return 0;\n\n    let totalDistance = 0;\n    try {\n      for (let i = 0; i < path.length - 1; i++) {\n        totalDistance += distance(cities[path[i]], cities[path[i + 1]]);\n      }\n      totalDistance += distance(cities[path[path.length - 1]], cities[path[0]]);\n    } catch (error) {\n      console.error('Error calculating path distance:', error);\n      return 0;\n    }\n    return totalDistance;\n  }\n\n  function distance(city1, city2) {\n    return Math.sqrt((city1.x - city2.x) ** 2 + (city1.y - city2.y) ** 2);\n  }\n\n  function drawBefore(path, lastChange) {\n    if (!beforeCanvas || !A.cities) return;\n\n    const ctx = beforeCanvas.getContext('2d');\n    ctx.clearRect(0, 0, beforeCanvas.width, beforeCanvas.height);\n\n    // Draw cities\n    ctx.fillStyle = 'blue';\n    A.cities.forEach((city) => {\n      ctx.beginPath();\n      ctx.arc(city.x, city.y, 5, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Draw the main path in red\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(A.cities[path[0]].x, A.cities[path[0]].y);\n    for (let i = 1; i < path.length; i++) {\n      ctx.lineTo(A.cities[path[i]].x, A.cities[path[i]].y);\n    }\n    ctx.stroke();\n\n    // Highlight the segment that will disappear (if any)\n    if (lastChange && lastChange.start >= 0 && lastChange.end >= 0) {\n      const { start, end } = lastChange;\n\n      ctx.strokeStyle = '#00FFFF'; // Bright cyan\n      ctx.lineWidth = 6; // Thicker line for emphasis\n      ctx.beginPath();\n      ctx.moveTo(A.cities[path[start]].x, A.cities[path[start]].y);\n      for (let i = start + 1; i <= end; i++) {\n        ctx.lineTo(A.cities[path[i]].x, A.cities[path[i]].y);\n      }\n      ctx.stroke();\n    }\n  }\n\n  function drawAfter(cities, path, lastChange) {\n    if (!afterCanvas) return;\n    const ctx = afterCanvas.getContext('2d');\n    ctx.clearRect(0, 0, afterCanvas.width, afterCanvas.height);\n\n    // Draw cities\n    ctx.fillStyle = 'blue';\n    cities.forEach(city => {\n      ctx.beginPath();\n      ctx.arc(city.x, city.y, 5, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Draw the main path in red\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(cities[path[0]].x, cities[path[0]].y);\n    path.forEach(index => {\n      ctx.lineTo(cities[index].x, cities[index].y);\n    });\n    ctx.lineTo(cities[path[0]].x, cities[path[0]].y); // Close the loop\n    ctx.stroke();\n\n    // Highlight the changed segments if they exist\n    if (lastChange && lastChange.start >= 0 && lastChange.end >= 0) {\n      const { start, end } = lastChange;\n\n      // Draw the original segment (before reversal) in bright cyan\n      ctx.strokeStyle = '#00FFFF'; // Bright cyan\n      ctx.lineWidth = 6; // Thicker line for emphasis\n      ctx.beginPath();\n      ctx.moveTo(cities[path[start]].x, cities[path[start]].y);\n      for (let i = start + 1; i <= end; i++) {\n        ctx.lineTo(cities[path[i]].x, cities[path[i]].y);\n      }\n      ctx.stroke();\n\n      // Draw the new segment (after reversal) in gold\n      ctx.strokeStyle = '#FFD700'; // Gold\n      ctx.lineWidth = 6; // Thicker line for emphasis\n      ctx.beginPath();\n      ctx.moveTo(cities[path[start]].x, cities[path[start]].y);\n      for (let i = end; i >= start; i--) {\n        ctx.lineTo(cities[path[i]].x, cities[path[i]].y);\n      }\n      ctx.stroke();\n    }\n  }\n\n  onMount(() => {\n    console.log('Component mounted');\n    m(v => ({\n      cities: [],\n      bestPath: [],\n      penultimatePath: [],\n      beforeDistance: 0,\n      afterDistance: 0,\n      improved: true,\n      step: 0\n    }));\n    A = m(dF3x);\n    console.log('Initial State:', A);\n  });\n</script>\n\n<h1>Traveling Salesman Problem</h1>\n<div style=\"display: flex; gap: 20px;\">\n  <div>\n    <h2>Before</h2>\n    <canvas bind:this={beforeCanvas} width=\"800\" height=\"600\"></canvas>\n    <p>Total Distance: {A?.beforeDistance ? A.beforeDistance.toFixed(2) : 'N/A'}</p>\n  </div>\n  <div>\n    <h2>After</h2>\n    <canvas bind:this={afterCanvas} width=\"800\" height=\"600\"></canvas>\n    <p>Total Distance: {A?.afterDistance ? A.afterDistance.toFixed(2) : 'N/A'}</p>\n  </div>\n</div>\n<button on:click={() => {\n  generateCities();\n}}>Generate Cities</button>\n<button on:click={() => {\n  if (A?.improved) {\n    solveTSP(m);\n  }\n}}>Solve TSP (Step-by-Step)</button>\n<button on:click={() => {\n  generateCities();\n}}>Reset</button>\n\n<p>Steps Taken: {A?.step}</p>\n<p>Improvement: {A?.beforeDistance && A?.afterDistance \n  ? `${(((A.beforeDistance - A.afterDistance) / A.beforeDistance) * 100).toFixed(2)}%` \n  : 'N/A'}</p>"],"names":["A","$.mutable_source","cities","bestPath","penultimatePath","beforeDistance","afterDistance","improved","step","lastChange","start","end","dF3x","Symbol","m","initialState","x","go","func","M","beforeCanvas","afterCanvas","generateCities","__name","newCities","Array","from","length","Math","random","y","newPath","_","i","initialDistance","pathDistance","v","set","drawBefore","$.safe_get","solveTSP","state","currentDistance","j","segment","slice","reverse","splice","newDistance","console","log","path","totalDistance","distance","error","city1","city2","sqrt","ctx","$.get","getContext","clearRect","width","height","fillStyle","forEach","city","beginPath","arc","PI","fill","strokeStyle","lineWidth","moveTo","lineTo","stroke","drawAfter","index","onMount","bind_this","canvas","$$value","$.set","canvas_1","set_text","text_2","safe_get","_a","toFixed","_b","event","button","button_1","button_2"],"mappings":"q0BAGMA,EAACC,EAAA,CACHC,OAAM,GACNC,SAAQ,GACRC,gBAAe,GACfC,eAAgB,EAChBC,cAAe,EACfC,UAAU,EACVC,KAAM,EACNC,YAAcC,OAAK,EAAMC,KAAO,KAI5B,MAAAC,EAAOC,OAAO,QAehB,IAAAC,UAbOC,IACL,IAAAC,MAASD,GACP,MAAAE,UAAMC,GACNA,IAASN,EACJI,GAETA,EAAIE,EAAKF,GACFC,IALD,MAOD,OAAAA,IATF,IAaCE,CAAC,CACPjB,OAAM,GACNC,SAAQ,GACRC,gBAAe,GACfC,eAAgB,EAChBC,cAAe,EACfC,UAAU,EACVC,KAAM,EACNC,YAAcC,OAAK,EAAMC,KAAO,SAG9BS,EAAYnB,IACZoB,EAAWpB,IAET,MAAAqB,EAAuBC,QAAA,KACrB,MAAAC,EAAYC,MAAMC,KAAO,CAAAC,OAAQ,KAAE,KAAA,CACvCX,EAAmB,IAAhBY,KAAKC,SACRC,EAAmB,IAAhBF,KAAKC,aAGJE,EAAUN,MAAMC,MAAOC,OAAQH,EAAUG,SAAW,CAAAK,EAAGC,IAAMA,IAC7DC,EAAkBC,aAAaJ,EAASP,GAE9CV,GAAEsB,IAAC,CACDlC,OAAQsB,EACRrB,SAAU4B,EACV3B,gBAAiB2B,EACjB1B,eAAgB6B,EAChB5B,cAAe4B,EACf3B,UAAU,EACVC,KAAM,EACNC,YAAcC,OAAK,EAAMC,KAAO,OAElC0B,EAAArC,EAAIc,EAAEF,IACN0B,aAAWtC,GAAEI,gBAAiBmC,EAAAvC,GAAES,YACvB8B,UAAAA,EAACvC,GAAEE,OAAMqC,EAAEvC,GAAEG,SAAQoC,EAAEvC,GAAES,cArBP,kBAwBvB+B,UAAY1B,IAChBA,GAAG2B,QACIA,EAAMlC,SAAiB,OAAAkC,iBAEpBtC,EAAUD,OAAAA,GAAWuC,EACvBC,EAAkBP,aAAahC,EAAUD,GAEtC,IAAA,IAAA+B,EAAI,EAAGA,EAAI9B,EAASwB,OAAS,EAAGM,IAC9B,IAAA,IAAAU,EAAIV,EAAI,EAAGU,EAAIxC,EAASwB,OAAQgB,IAAK,CACtC,MAAAZ,MAAc5B,GACdyC,EAAUb,EAAQc,MAAMZ,EAAGU,EAAI,GAAGG,UACxCf,EAAQgB,OAAOd,EAAGW,EAAQjB,UAAWiB,GAE/B,MAAAI,EAAcb,aAAaJ,EAAS7B,MACtC8C,EAAcN,YAEXD,EACHtC,SAAU4B,EACV3B,gBAAiBD,EACjBG,cAAe0C,EACfzC,UAAU,EACVC,KAAMiC,EAAMjC,KAAO,EACnBC,YAAcC,MAAOuB,EAAGtB,IAAKgC,GAGnC,WAGUF,EAAOlC,UAAU,EAAOE,YAAcC,OAAK,EAAMC,KAAO,OAGtE0B,EAAArC,EAAIc,EAAEF,IACNqC,QAAQC,IAAI,mBAAkBlD,IAC9BsC,aAAWtC,GAAEI,gBAAiBmC,EAAAvC,GAAES,YACvB8B,UAAAA,EAACvC,GAAEE,OAAMqC,EAAEvC,GAAEG,SAAQoC,EAAEvC,GAAES,cAlCtB,YAqCL,SAAA0B,aAAagB,EAAMjD,GACrB,IAAAiD,IAASjD,GAAUiD,EAAKxB,OAAS,GAAKzB,EAAOyB,OAAS,EAAU,OAAA,EAEjE,IAAAyB,EAAgB,EAChB,IACO,IAAA,IAAAnB,EAAI,EAAGA,EAAIkB,EAAKxB,OAAS,EAAGM,IAClBmB,GAAAC,SAASnD,EAAOiD,EAAKlB,IAAK/B,EAAOiD,EAAKlB,EAAI,KAE7DmB,GAAiBC,SAASnD,EAAOiD,EAAKA,EAAKxB,OAAS,IAAKzB,EAAOiD,EAAK,IACtE,OAAQG,GAEA,OADCL,QAAAK,MAAM,mCAAoCA,GAC3C,CACT,CACO,OAAAF,CACT,CAES,SAAAC,SAASE,EAAOC,GAChB,OAAA5B,KAAK6B,MAAMF,EAAMvC,EAAIwC,EAAMxC,IAAM,GAAKuC,EAAMzB,EAAI0B,EAAM1B,IAAM,EACrE,CAES,SAAAQ,WAAWa,EAAM1C,SACnBW,KAAYmB,EAAKvC,GAAEE,OAAM,OAExB,MAAAwD,EAAMC,EAAAvC,GAAawC,WAAW,MAChCF,EAAAG,UAAU,EAAG,EAAGF,EAAAvC,GAAa0C,MAAOH,EAAAvC,GAAa2C,QAGrDL,EAAIM,UAAY,OAChBzB,EAAAvC,GAAEE,OAAO+D,SAASC,IAChBR,EAAIS,YACAT,EAAAU,IAAIF,EAAKlD,EAAGkD,EAAKpC,EAAG,EAAG,EAAa,EAAVF,KAAKyC,IACnCX,EAAIY,UAINZ,EAAIa,YAAc,MAClBb,EAAIc,UAAY,EAChBd,EAAIS,YACJT,EAAIe,OAAOlC,EAAAvC,GAAEE,OAAOiD,EAAK,IAAInC,EAACuB,EAAEvC,GAAEE,OAAOiD,EAAK,IAAIrB,WACzCG,EAAI,EAAGA,EAAIkB,EAAKxB,OAAQM,IAC/ByB,EAAIgB,OAAOnC,EAAAvC,GAAEE,OAAOiD,EAAKlB,IAAIjB,EAACuB,EAAEvC,GAAEE,OAAOiD,EAAKlB,IAAIH,GAKhD,GAHJ4B,EAAIiB,SAGAlE,GAAcA,EAAWC,OAAS,GAAKD,EAAWE,KAAO,EAAG,aACtDD,EAAOC,IAAAA,GAAQF,EAEvBiD,EAAIa,YAAc,UAClBb,EAAIc,UAAY,EAChBd,EAAIS,YACJT,EAAIe,OAAOlC,EAAAvC,GAAEE,OAAOiD,EAAKzC,IAAQM,EAACuB,EAAEvC,GAAEE,OAAOiD,EAAKzC,IAAQoB,WACjDG,EAAIvB,EAAQ,EAAGuB,GAAKtB,EAAKsB,IAChCyB,EAAIgB,OAAOnC,EAAAvC,GAAEE,OAAOiD,EAAKlB,IAAIjB,EAACuB,EAAEvC,GAAEE,OAAOiD,EAAKlB,IAAIH,GAEpD4B,EAAIiB,QACN,CACF,CAES,SAAAC,UAAU1E,EAAQiD,EAAM1C,SAC1BY,GAAW,OACV,MAAAqC,EAAMC,EAAAtC,GAAYuC,WAAW,MAuB/B,GAtBAF,EAAAG,UAAU,EAAG,EAAGF,EAAAtC,GAAYyC,MAAOH,EAAAtC,GAAY0C,QAGnDL,EAAIM,UAAY,OACT9D,EAAA+D,SAAQC,IACbR,EAAIS,YACAT,EAAAU,IAAIF,EAAKlD,EAAGkD,EAAKpC,EAAG,EAAG,EAAa,EAAVF,KAAKyC,IACnCX,EAAIY,UAINZ,EAAIa,YAAc,MAClBb,EAAIc,UAAY,EAChBd,EAAIS,YACJT,EAAIe,OAAOvE,EAAOiD,EAAK,IAAInC,EAAGd,EAAOiD,EAAK,IAAIrB,GACzCqB,EAAAc,SAAQY,IACPnB,EAAAgB,OAAOxE,EAAO2E,GAAO7D,EAAGd,EAAO2E,GAAO/C,MAE5C4B,EAAIgB,OAAOxE,EAAOiD,EAAK,IAAInC,EAAGd,EAAOiD,EAAK,IAAIrB,GAC9C4B,EAAIiB,SAGAlE,GAAcA,EAAWC,OAAS,GAAKD,EAAWE,KAAO,EAAG,aACtDD,EAAOC,IAAAA,GAAQF,EAGvBiD,EAAIa,YAAc,UAClBb,EAAIc,UAAY,EAChBd,EAAIS,YACJT,EAAIe,OAAOvE,EAAOiD,EAAKzC,IAAQM,EAAGd,EAAOiD,EAAKzC,IAAQoB,WAC7CG,EAAIvB,EAAQ,EAAGuB,GAAKtB,EAAKsB,IAChCyB,EAAIgB,OAAOxE,EAAOiD,EAAKlB,IAAIjB,EAAGd,EAAOiD,EAAKlB,IAAIH,GAEhD4B,EAAIiB,SAGJjB,EAAIa,YAAc,UAClBb,EAAIc,UAAY,EAChBd,EAAIS,YACJT,EAAIe,OAAOvE,EAAOiD,EAAKzC,IAAQM,EAAGd,EAAOiD,EAAKzC,IAAQoB,WAC7CG,EAAItB,EAAKsB,GAAKvB,EAAOuB,IAC5ByB,EAAIgB,OAAOxE,EAAOiD,EAAKlB,IAAIjB,EAAGd,EAAOiD,EAAKlB,IAAIH,GAEhD4B,EAAIiB,QACN,CACF,CA3GSpD,OAAAY,aAAA,gBAgBAZ,OAAA8B,SAAA,YAIA9B,OAAAe,WAAA,cAuCAf,OAAAqD,UAAA,aAkDTE,GAAc,KACZ7B,QAAQC,IAAI,qBACZpC,GAAEsB,IAAC,CACDlC,OAAM,GACNC,SAAQ,GACRC,gBAAe,GACfC,eAAgB,EAChBC,cAAe,EACfC,UAAU,EACVC,KAAM,MAER6B,EAAArC,EAAIc,EAAEF,IACNqC,QAAQC,IAAI,mBAAkBlD,oDAQX+E,EAAAC,GAAAC,GAAAC,EAAA9D,aAAAA,4DAKA2D,EAAAI,GAAAF,GAAAC,EAAA7D,aAAAA,wMAgBN+D,EAAAC,EAAA,iBAAA9C,OAAAA,EAAA+C,EAAAtF,SAAG,EAAAuF,EAAA/E,OAAI,iDApBA,cAAA+E,EAAAD,EAAAtF,aAAGK,gBAAckC,EAAGvC,GAAEK,eAAemF,QAAQ,GAAK,kBAKlD,cAAAD,EAAAD,EAAAtF,aAAGM,eAAaiC,EAAGvC,GAAEM,cAAckF,QAAQ,GAAK,oBAgBvD,cAAAD,EAAAD,EAAAtF,aAAGK,kBAAckC,OAAAA,EAAAA,EAAIvC,SAAG,EAAAyF,EAAAnF,eAC/B,KAAAiC,EAAAvC,GAAEK,eAAiBkC,EAAAvC,GAAEM,eAAaiC,EAAIvC,GAAEK,eAAkB,KAAKmF,QAAQ,MAC7E,WAfoBE,EAAA,QAAAC,GAAA,KACRrE,OAEQoE,EAAA,QAAAE,GAAA,qBAClBN,EAAAtF,aAAGO,WACLiC,EAAS1B,MAGW4E,EAAA,QAAAG,GAAA,KACRvE"}