{"version":3,"mappings":";4pCAoBO,SAASA,SAASC,EAAMC,GAAKC,EAAYC,GAAiB,CAAC,EAAG,IAChEC,GAA4B,IAAfF,GACFG,IAGf,IAAIC,EAASN,EAGTO,EAAoB,KAGpBC,EAAmB,KAGnBC,EAAYC,EAEZC,EAAQT,EAAa,EAAIU,EAAqB,EAE9CC,GAAa,EAEjB,MAAMC,EAAaC,QAAA,CAC8Cd,EAChEe,GAAO,KAEMH,GAAA,EACbI,EAAcD,EAAMf,KALF,cAQbgB,EACyBF,QAAA,CAAAG,EAC2CjB,KAErE,GAAAQ,KAAeA,EAAYS,GAAgB,OAG/C,IAAIC,GAAW,EAEX,GAAAf,IAAmC,IAAtBD,EAAsB,CACtC,GAAmB,IAAfD,EAAkB,CACf,MAAAkB,EAAOC,EAA2Bf,GAEpCc,IAASE,EACInB,EAAA,EACNiB,IAASG,EACHpB,EAAAqB,KAEhBrB,EAAgBsB,SAASL,EAAKM,UAAU,MAClBvB,IAGrBA,EAAgBM,EAAYe,KAAW,EAG7C,GAGSf,IAFUN,EAAgBD,IAK/BI,EAASqB,IAETC,EAAiBtB,GACjBuB,GAAc,GACHV,GAAA,EACKhB,GAAA,EAEpB,CAEMM,GACCF,EACHuB,EAAcvB,GACJN,IACVM,EAAoBwB,GAAO,IAAM9B,EAAGK,MAGjCE,GACHwB,EAAaxB,GAAkB,KACXA,EAAA,UAIjBA,EACHsB,EAActB,GACJP,IACSO,EAAAuB,GAAO,IAAM9B,EAAGK,EAAQ,CAACJ,EAAa,EAAGC,OAGzDI,GACHyB,EAAazB,GAAmB,KACXA,EAAA,SAKnBY,GAEHU,GAAc,KApEM,iBAwEtBI,GAAM,KACQpB,GAAA,EACbZ,EAAGa,GACED,GACJI,EAAc,KAAM,QAEnBN,GAECP,IACME,EAAA4B,EAEX,CCtHO,SAASC,UAAUnC,EAAMoC,EAAeC,GAC1CjC,GACWC,IAGf,IAGI8B,EAGAG,EANAhC,EAASN,EAQbiC,GAAM,KACDE,KAAeA,EAAYC,OAE3BE,IACHN,EAAaM,GACJA,EAAA,MAGNH,IACHG,EAASP,GAAO,IAAMM,EAAU/B,EAAQ6B,SAEvCvB,GAECR,IACME,EAAA4B,EAEX,CDtBgBnB,OAAAhB,SAAA,YCPAgB,OAAAoB,UAAA,aCChB,IAAII,IAAmB,EA8KhB,SAASC,sBAAsBvC,GACrC,IAAIwC,EAA4BF,GAE5B,IAEI,OADYA,IAAA,EACZ,CAACtC,IAAMsC,GAChB,CAAW,QACUA,GAAAE,CACrB,CACA,CCkDA,SAASC,4BAA4BC,SAC7B,cAAAC,EAAAD,EAAcE,UAAd,EAAAD,EAAmBE,KAAK,CAChC,CAYO,SAASC,KAAKC,EAAOC,EAAKtC,EAAOuC,SAMnCC,EALAC,EAA6C,KAAhCzC,EAAQ0C,GACrBC,GAASC,IAAiD,KAA5B5C,EAAQ6C,GACtCC,EAA2C,KAA/B9C,EAAQ+C,GACpBC,EAA2C,KAAnChD,EAAQiD,GAChBC,GAAe,EAGfJ,GACFN,EAAYU,GAAgBrB,uBAAsB,IAAwBQ,EAAMC,KAEjFE,EAA+BH,EAAMC,GAKlC,IAoCAa,EApCAC,EAAiBC,KAAgBhB,GAASiB,KAAgBjB,EAE1DkB,EACFT,KACC,OAAAb,EAAAuB,EAAenB,EAAOC,SAAM,EAAAL,EAAAwB,OAC3BL,GAAkBd,KAAOD,IAAWqB,GAAOrB,EAAMC,GAAOoB,WAC3D,EAEGC,EAAA,EACAC,GAAiB,EACjBC,GAAgB,EAEhBC,EAAqB1D,QAAA,KACRyD,GAAA,EACZD,IACcA,GAAA,EAECD,EADdX,EACce,EAAgCxB,GAEdA,GAI9BoB,IAXW,gBAyBnB,QAXmB,IAAfnB,QAAyC,IAAbD,IAC3BgB,GAAUZ,GACYqB,IAG1BxB,EAAasB,IACTP,KAAef,IAKhBG,EACHQ,EAAe/C,QAAA,KACV,IAAA6D,EAA0B5B,EAAMC,GAChC,YAAU,IAAV2B,EAA4BH,KACfF,GAAA,EACDC,GAAA,EACTI,KALC,cAOH,CAGF,IAAAC,GAAkBzB,EAAY0B,EAAUC,IAC3C,IAAwB/B,EAAMC,KAE/B4B,EAAeG,GAAKC,EACpBnB,EAAe/C,QAAA,KACV,IAAA6D,EAAQM,EAAIL,GAET,YADO,IAAVD,IAAqBN,OAAmC,QAC3C,IAAVM,EAAsBN,EAAiBM,IAHtC,SAKX,CAGM,GAA8B,KAA9BjE,EAAQwE,IAA2B7B,EAChC,OAAAQ,EAKR,GAAII,EAAQ,CACX,IAAIkB,EAAgBpC,EAAMqC,SACnB,gBAA6BT,EAA8BU,GAC7D,OAAAC,UAAUC,OAAS,GAKjBlC,GAAUgC,IAAYF,IAAiBvB,GAClBK,EAAQoB,EAAWxB,IAAWc,GAEjDA,GAEAd,GAER,CACH,CAKC,IAAI2B,GAAa,EAKbC,EAAsBC,EAAexC,GACrCR,EAAgBmC,GAAQ,KAC3B,IAAIc,EAAe9B,IACf+B,EAAcX,EAAIQ,GAEtB,OAAID,GACUA,GAAA,EAENI,GAIAH,EAAoBrB,EAAIuB,KAU1B,OANHnC,GACHyB,EAAIvC,GAGAS,IAAWT,EAAcmD,OAASC,GAEhC,SAA6BnB,EAA8BU,GAa7D,GAAAC,UAAUC,OAAS,EAAG,CACnB,MAAAQ,EAAYV,EAAWJ,EAAIvC,GAAiBW,GAASG,EAAWwC,EAAMrB,GAASA,EAErF,IAAKjC,EAAcmD,OAAOE,GAAY,CASjC,GARSP,GAAA,EACbrB,EAAIsB,EAAqBM,GAGrBxB,QAAoC,IAAnBF,IACHA,EAAA0B,GAGdtD,4BAA4BC,GACxB,OAAAiC,EAGAF,GAAA,IAAMQ,EAAIvC,IACtB,CAEU,OAAAiC,CACV,CAEM,OAAAlC,4BAA4BC,GACxBA,EAAc0B,EAGfa,EAAIvC,EACX,CACF,CClYO,SAASuD,iBAAiB/D,GAEhC,OAAO,cAAcgE,GAEpB,WAAAC,CAAYC,GACLC,MAAA,CACLnE,eACGkE,GAEP,EAEA,CFmIgBtF,OAAAyB,sBAAA,yBC2DPzB,OAAA2B,4BAAA,+BAcO3B,OAAAgC,KAAA,QCvNAhC,OAAAmF,iBAAA,oBAkBhB,MAAMK,GAAN,MAAMA,kBAYL,WAAAH,CAAYC,SAVZG,aAAAC,KAAAC,GAGAF,aAAAC,KAAAE,GAQK,IAAAC,MAAcC,IAMdC,EAAc/F,QAAA,CAAAkC,EAAK2B,KACtB,IAAImC,EAAIpB,EAAef,GAAO,GAAO,GAE9B,OADCgC,EAAAxC,IAAInB,EAAK8D,GACVA,IAHS,cASjB,MAAM/D,EAAQ,IAAIgE,MACjB,IAAMX,EAAQrD,OAAS,CAAE,EAAGiE,SAAU,IACtC,CACC/B,IAAA,CAAIgC,EAAQnE,IACJmC,EAAI0B,EAAQ1B,IAAInC,IAAS+D,EAAW/D,EAAMoE,QAAQjC,IAAIgC,EAAQnE,KAEtEqE,IAAA,CAAIF,EAAQnE,IAEPA,IAASkB,IAETiB,EAAA0B,EAAQ1B,IAAInC,IAAS+D,EAAW/D,EAAMoE,QAAQjC,IAAIgC,EAAQnE,KACvDoE,QAAQC,IAAIF,EAAQnE,IAE5BqB,IAAA,CAAI8C,EAAQnE,EAAM6B,KACbR,EAAAwC,EAAQ1B,IAAInC,IAAS+D,EAAW/D,EAAM6B,GAAQA,GAC3CuC,QAAQ/C,IAAI8C,EAAQnE,EAAM6B,MAKpCyC,aAAAZ,KAAKE,GAAaN,EAAQiB,QAAUA,EAAUC,GAAOlB,EAAQlE,UAAW,CACvE+E,OAAQb,EAAQa,OAChB5G,OAAQ+F,EAAQ/F,OAChB0C,QACAwE,QAASnB,EAAQmB,QACjBC,MAAOpB,EAAQoB,QAAS,EACxBC,QAASrB,EAAQqB,YAIb,OAAA9E,EAAS,MAAAyD,OAAA,EAAAA,EAAArD,gBAAO2E,UAA2B,IAAjBtB,EAAQuB,MAC3BC,IAGZR,aAAAZ,KAAKC,EAAU1D,EAAMiE,UAErB,UAAWhE,KAAO6E,OAAOC,KAAKC,aAAAvB,KAAKE,IACtB,SAAR1D,GAA0B,aAARA,GAA8B,QAARA,GAC5CgF,EAAgBxB,KAAMxD,EAAK,CAC1B,GAAAiC,GACQ,OAAA8C,aAAAvB,KAAKE,GAAU1D,EACtB,EAED,GAAAmB,CAAIQ,GACEoD,aAAAvB,KAAAE,GAAU1D,GAAO2B,CACtB,EACDsD,YAAY,IAIdF,aAAAvB,KAAKE,GAAUwB,KAAiDC,IACxDN,OAAAO,OAAOrF,EAAOoF,IAGjBJ,aAAAvB,KAAAE,GAAU2B,SAAW,KACzBC,EAAQP,kBAAKrB,IAEhB,CAGC,IAAAwB,CAAKnF,GACCgF,aAAAvB,KAAAE,GAAUwB,KAAKnF,EACtB,CAOC,GAAAwF,CAAIC,EAAOC,GACVV,aAAAvB,KAAKC,GAAQ+B,GAAST,kBAAKtB,GAAQ+B,IAAU,GAGvC,MAAAE,cAASC,IAASF,EAASG,KAAKpC,QAASmC,IAApC,MAEX,OADAZ,aAAAvB,KAAKC,GAAQ+B,GAAOK,KAAKH,GAClB,KACNX,aAAAvB,KAAKC,GAAQ+B,GAAST,aAAKvB,KAAAC,GAAQ+B,GAAOM,QAA+B9I,GAAOA,IAAO0I,IAE1F,CAEC,QAAAL,GACCN,aAAAvB,KAAKE,GAAU2B,UACjB,GA5GC5B,EAAA,IAAAsC,QAGArC,EAAA,IAAAqC,QALsBjI,OAAAwF,GAAA,oBAAvB,IAAMJ,GAANI,q6CChEa0C,GAAW,oSCOW,IAAAC,EAAUC,KAAAC,EAAA,0BAAaC,oBAAS,MAAMC,oBAAS,MAOhFC,GAAW,IAAAH,EAAAI,OAAcC,KAAKrF,IAAGgF,EAAAK,QAIlCC,GAAc,oCACsBR,WAAYG,IAAOC,IAC/CF,EAAAI,OAAAC,KAAKE,YAGT,IAAAC,KAAiB,GACjBC,KAAmB,GACnBC,IAAe,MAEnBC,IAAc,KACP,MAAAC,EAAqBZ,EAAAI,OAAAC,KAAKQ,WAAgB,KAC3CC,EAAAN,KACHO,EAAAN,GAAY,GACRO,IAAGC,MAAW,KACjBF,EAAAL,EAAQQ,SAASR,OAAS,iBAAe,UAMrC,OADPK,EAAAP,GAAU,GACHI,KAGF,MAAAO,wBAAgC,gDAI9B,MAAAC,wBAAyB,kEAEgBnB,gIAEGC,kCAArBmB,GAAAvB,IAAW,GAACuB,IAAZ,yBAAA7H,EAAAsG,UAAW,EAAAtG,EAAA,uDAFd6H,GAAAvB,IAAW,GAACuB,IAAZ,yBAAA7H,EAAAsG,UAAW,EAAAtG,EAAA,0DAM/B,MAAA4H,wBAAyB,kEAEUnB,kCAArBoB,GAAAvB,IAAW,GAACuB,IAAZ,yBAAA7H,EAAAsG,UAAW,EAAAtG,EAAA,+DAXhB,KAAC8H,GAAAC,EAAAC,GAAA,yFAkBfd,kDADGD,IAASc,EAAAE,uDAFXjB,IAAOe,EAAAG,sCCzDZ,MAAeC,GAAA7E,iBAAiB8E,MCAnBC,GAAQ,CACpB,IAAMC,IAAA,IAAAC,OAAO,2BAAYC,+CAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,yDAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,yDAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,oDAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,oDAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,+CAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,wCAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,iDAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,+CAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,2BAAYC,uDAAAC,KACzB,IAAMH,IAAA,IAAAC,OAAO,4BAAaC,uDAAAC,KAC1B,IAAMH,IAAA,IAAAC,OAAO,4BAAYC,4DAAAC,MAGbC,GAAe,GAEfC,GAAa,CACxB,IAAK,CAAC,GACN,WAAY,CAAC,GACb,cAAe,CAAC,GAChB,UAAW,CAAC,GACZ,QAAS,CAAC,GACV,UAAW,CAAC,GACZ,SAAU,CAAC,GACX,QAAS,CAAC,GACV,oBAAqB,CAAC,IACtB,SAAU,CAAC,KAGAC,GAAQ,CACpBC,YAAc1K,QAAA,EAAG2K,YAAcC,QAAQD,MAAMA,KAA/B,eAEdE,QAAgB7K,QAAA,QAAN,WACV8K,UAAW,IAGCC,GAAWhE,OAAOiE,YAAYjE,OAAOkE,QAAQR,GAAMK,WAAWI,KAAI,EAAEC,EAAG7H,KAAO,CAAC6H,EAAG7H,EAAE8H,WAEpFC,IAAO,EAEPD,YAAUE,EAAMzH,IAAUkH,GAASO,GAAMzH,IAAhC","names":["if_block","node","fn","root_index","hydrate_index","hydrating","hydrate_next","anchor","consequent_effect","alternate_effect","condition","UNINITIALIZED","flags","EFFECT_TRANSPARENT","has_branch","set_branch","__name","flag","update_branch","new_condition","mismatch","data","read_hydration_instruction","HYDRATION_START","HYDRATION_START_ELSE","Infinity","parseInt","substring","remove_nodes","set_hydrate_node","set_hydrating","resume_effect","branch","pause_effect","block","hydrate_node","component","get_component","render_fn","effect","is_store_binding","capture_store_binding","previous_is_store_binding","has_destroyed_component_ctx","current_value","_a","ctx","d","prop","props","key","fallback","prop_value","immutable","PROPS_IS_IMMUTABLE","runes","legacy_mode_flag","PROPS_IS_RUNES","bindable","PROPS_IS_BINDABLE","lazy","PROPS_IS_LAZY_INITIAL","is_store_sub","getter","is_entry_props","STATE_SYMBOL","LEGACY_PROPS","setter","get_descriptor","set","v","fallback_value","fallback_dirty","fallback_used","get_fallback","untrack","props_invalid_value","value","derived_getter","derived","derived_safe_equal","f","LEGACY_DERIVED_PROP","get","PROPS_IS_UPDATED","legacy_parent","$$legacy","mutation","arguments","length","from_child","inner_current_value","mutable_source","parent_value","child_value","equals","safe_equals","new_value","proxy","asClassComponent","Svelte4Component","constructor","options","super","_Svelte4Component","__privateAdd","this","_events","_instance","sources","Map","add_source","s","Proxy","$$events","target","Reflect","has","__privateSet","hydrate","mount","context","intro","recover","$$host","sync","flushSync","Object","keys","__privateGet","define_property","enumerable","$set","next","assign","$destroy","unmount","$on","event","callback","cb","args","call","push","filter","WeakMap","matchers","components","$.prop","$$props","data_0","data_1","$.user_pre_effect","stores","page","$.user_effect","notify","mounted","navigated","title","onMount","unsubscribe","subscribe","$.get","$.set","tick","then","document","Pyramid_1","Pyramid_0","$$value","consequent","$$render","alternate","consequent_1","consequent_2","root","Root","nodes","__vitePreload","import","__VITE_PRELOAD__","url","server_loads","dictionary","hooks","handleError","error","console","reroute","transport","decoders","fromEntries","entries","map","k","decode","hash","type"],"ignoreList":[0,1,2,3,4],"sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../../../../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/store.js","../../../../../../node_modules/svelte/src/internal/client/reactivity/props.js","../../../../../../node_modules/svelte/src/legacy/legacy-client.js","../../../../../generated/client-optimized/matchers.js","../../../../../generated/root.svelte","../../../../../generated/root.js","../../../../../generated/client-optimized/app.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START, HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node, elseif?: [number,number]) => void, flag?: boolean) => void) => void} fn\n * @param {[number,number]} [elseif]\n * @returns {void}\n */\nexport function if_block(node, fn, [root_index, hydrate_index] = [0, 0]) {\n\tif (hydrating && root_index === 0) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = root_index > 0 ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (\n\t\t/** @type {(anchor: Node, elseif?: [number,number]) => void} */ fn,\n\t\tflag = true\n\t) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node, elseif?: [number,number]) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating && hydrate_index !== -1) {\n\t\t\tif (root_index === 0) {\n\t\t\t\tconst data = read_hydration_instruction(anchor);\n\n\t\t\t\tif (data === HYDRATION_START) {\n\t\t\t\t\thydrate_index = 0;\n\t\t\t\t} else if (data === HYDRATION_START_ELSE) {\n\t\t\t\t\thydrate_index = Infinity;\n\t\t\t\t} else {\n\t\t\t\t\thydrate_index = parseInt(data.substring(1));\n\t\t\t\t\tif (hydrate_index !== hydrate_index) {\n\t\t\t\t\t\t// if hydrate_index is NaN\n\t\t\t\t\t\t// we set an invalid index to force mismatch\n\t\t\t\t\t\thydrate_index = condition ? Infinity : -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is_else = hydrate_index > root_index;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t\thydrate_index = -1; // ignore hydration in next else if\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor, [root_index + 1, hydrate_index]));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\nimport { EFFECT_TRANSPARENT } from '#client/constants';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (component) {\n\t\t\teffect = branch(() => render_fn(anchor, component));\n\t\t}\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Derived, Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport { get, captured_signals, untrack } from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { LEGACY_DERIVED_PROP, LEGACY_PROPS, STATE_SYMBOL } from '#client/constants';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (!p) continue;\n\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\n\t\t\tfor (const key of Object.getOwnPropertySymbols(p)) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * @param {Derived} current_value\n * @returns {boolean}\n */\nfunction has_destroyed_component_ctx(current_value) {\n\treturn current_value.ctx?.d ?? false;\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\t(bindable &&\n\t\t\t(get_descriptor(props, key)?.set ??\n\t\t\t\t(is_entry_props && key in props && ((v) => (props[key] = v))))) ||\n\t\tundefined;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0 && runes) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\t// Ensure we eagerly capture the initial value if it's bindable\n\tif (bindable) {\n\t\tget(current_value);\n\t}\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\n\t\t\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\tif (has_destroyed_component_ctx(current_value)) {\n\t\t\treturn current_value.v;\n\t\t}\n\n\t\treturn get(current_value);\n\t};\n}\n","/** @import { ComponentConstructorOptions, ComponentType, SvelteComponent, Component } from 'svelte' */\nimport { DIRTY, LEGACY_PROPS, MAYBE_DIRTY } from '../internal/client/constants.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { mutable_source, set } from '../internal/client/reactivity/sources.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { active_effect, flushSync, get, set_signal_status } from '../internal/client/runtime.js';\nimport { lifecycle_outside_component } from '../internal/shared/errors.js';\nimport { define_property, is_array } from '../internal/shared/utils.js';\nimport * as w from '../internal/client/warnings.js';\nimport { DEV } from 'esm-env';\nimport { FILENAME } from '../constants.js';\nimport { component_context, dev_current_component_function } from '../internal/client/context.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {ComponentConstructorOptions<Props> & {\n * \tcomponent: ComponentType<SvelteComponent<Props, Events, Slots>> | Component<Props>;\n * }} options\n * @returns {SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {SvelteComponent<Props, Events, Slots> | Component<Props>} component\n * @returns {ComponentType<SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Support using the component as both a class and function during the transition period\n * @typedef  {{new (o: ComponentConstructorOptions): SvelteComponent;(...args: Parameters<Component<Record<string, any>>>): ReturnType<Component<Record<string, any>, Record<string, any>>>;}} LegacyComponentType\n */\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {ComponentConstructorOptions & {\n\t *  component: any;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\tvar sources = new Map();\n\n\t\t/**\n\t\t * @param {string | symbol} key\n\t\t * @param {unknown} value\n\t\t */\n\t\tvar add_source = (key, value) => {\n\t\t\tvar s = mutable_source(value, false, false);\n\t\t\tsources.set(key, s);\n\t\t\treturn s;\n\t\t};\n\n\t\t// Replicate coarse-grained props through a proxy that has a version source for\n\t\t// each property, which is incremented on updates to the property itself. Do not\n\t\t// use our $state proxy because that one has fine-grained reactivity.\n\t\tconst props = new Proxy(\n\t\t\t{ ...(options.props || {}), $$events: {} },\n\t\t\t{\n\t\t\t\tget(target, prop) {\n\t\t\t\t\treturn get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t},\n\t\t\t\thas(target, prop) {\n\t\t\t\t\t// Necessary to not throw \"invalid binding\" validation errors on the component side\n\t\t\t\t\tif (prop === LEGACY_PROPS) return true;\n\n\t\t\t\t\tget(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));\n\t\t\t\t\treturn Reflect.has(target, prop);\n\t\t\t\t},\n\t\t\t\tset(target, prop, value) {\n\t\t\t\t\tset(sources.get(prop) ?? add_source(prop, value), value);\n\t\t\t\t\treturn Reflect.set(target, prop, value);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tanchor: options.anchor,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro ?? false,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\t// We don't flushSync for custom element wrappers or if the user doesn't want it\n\t\tif (!options?.props?.$$host || options.sync === false) {\n\t\t\tflushSync();\n\t\t}\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(() => {\n\t\tfn();\n\t\tvar effect = /** @type {import('#client').Effect} */ (active_effect);\n\t\t// If the effect is immediately made dirty again, mark it as maybe dirty to emulate legacy behaviour\n\t\tif ((effect.f & DIRTY) !== 0) {\n\t\t\tlet filename = \"a file (we can't know which one)\";\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tfilename = dev_current_component_function?.[FILENAME] ?? filename;\n\t\t\t}\n\t\t\tw.legacy_recursive_reactive_block(filename);\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t});\n}\n\n/**\n * Function to mimic the multiple listeners available in svelte 4\n * @deprecated\n * @param {EventListener[]} handlers\n * @returns {EventListener}\n */\nexport function handlers(...handlers) {\n\treturn function (event) {\n\t\tconst { stopImmediatePropagation } = event;\n\t\tlet stopped = false;\n\n\t\tevent.stopImmediatePropagation = () => {\n\t\t\tstopped = true;\n\t\t\tstopImmediatePropagation.call(event);\n\t\t};\n\n\t\tconst errors = [];\n\n\t\tfor (const handler of handlers) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error `this` is not typed\n\t\t\t\thandler?.call(this, event);\n\t\t\t} catch (e) {\n\t\t\t\terrors.push(e);\n\t\t\t}\n\n\t\t\tif (stopped) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (let error of errors) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\t};\n}\n\n/**\n * Function to create a `bubble` function that mimic the behavior of `on:click` without handler available in svelte 4.\n * @deprecated Use this only as a temporary solution to migrate your automatically delegated events in Svelte 5.\n */\nexport function createBubbler() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createBubbler');\n\t}\n\n\treturn (/**@type {string}*/ type) => (/**@type {Event}*/ event) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\nexport {\n\tonce,\n\tpreventDefault,\n\tself,\n\tstopImmediatePropagation,\n\tstopPropagation,\n\ttrusted,\n\tpassive,\n\tnonpassive\n} from '../internal/client/dom/legacy/event-modifiers.js';\n","export const matchers = {};","<!-- This file is generated by @sveltejs/kit — do not edit it! -->\n<svelte:options runes={true} />\n<script>\n\timport { setContext, onMount, tick } from 'svelte';\n\timport { browser } from '$app/environment';\n\n\t// stores\n\tlet { stores, page, constructors, components = [], form, data_0 = null, data_1 = null } = $props();\n\n\tif (!browser) {\n\t\tsetContext('__svelte__', stores);\n\t}\n\n\tif (browser) {\n\t\t$effect.pre(() => stores.page.set(page));\n\t} else {\n\t\tstores.page.set(page);\n\t}\n\t$effect(() => {\n\t\tstores;page;constructors;components;form;data_0;data_1;\n\t\tstores.page.notify();\n\t});\n\n\tlet mounted = $state(false);\n\tlet navigated = $state(false);\n\tlet title = $state(null);\n\n\tonMount(() => {\n\t\tconst unsubscribe = stores.page.subscribe(() => {\n\t\t\tif (mounted) {\n\t\t\t\tnavigated = true;\n\t\t\t\ttick().then(() => {\n\t\t\t\t\ttitle = document.title || 'untitled page';\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tmounted = true;\n\t\treturn unsubscribe;\n\t});\n\n\tconst Pyramid_1=$derived(constructors[1])\n</script>\n\n{#if constructors[1]}\n\t{@const Pyramid_0 = constructors[0]}\n\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t<Pyramid_0 bind:this={components[0]} data={data_0} {form}>\n\t\t\t\t\t\t\t\t<!-- svelte-ignore binding_property_non_reactive -->\n\t\t\t\t\t\t\t\t\t\t<Pyramid_1 bind:this={components[1]} data={data_1} {form} />\n\t\t\t\t\t\t\t</Pyramid_0>\n\t\n{:else}\n\t{@const Pyramid_0 = constructors[0]}\n\t<!-- svelte-ignore binding_property_non_reactive -->\n\t<Pyramid_0 bind:this={components[0]} data={data_0} {form} />\n\t\n{/if}\n\n{#if mounted}\n\t<div id=\"svelte-announcer\" aria-live=\"assertive\" aria-atomic=\"true\" style=\"position: absolute; left: 0; top: 0; clip: rect(0 0 0 0); clip-path: inset(50%); overflow: hidden; white-space: nowrap; width: 1px; height: 1px\">\n\t\t{#if navigated}\n\t\t\t{title}\n\t\t{/if}\n\t</div>\n{/if}","import { asClassComponent } from 'svelte/legacy';\nimport Root from './root.svelte';\nexport default asClassComponent(Root);","export { matchers } from './matchers.js';\n\nexport const nodes = [\n\t() => import('./nodes/0'),\n\t() => import('./nodes/1'),\n\t() => import('./nodes/2'),\n\t() => import('./nodes/3'),\n\t() => import('./nodes/4'),\n\t() => import('./nodes/5'),\n\t() => import('./nodes/6'),\n\t() => import('./nodes/7'),\n\t() => import('./nodes/8'),\n\t() => import('./nodes/9'),\n\t() => import('./nodes/10'),\n\t() => import('./nodes/11')\n];\n\nexport const server_loads = [];\n\nexport const dictionary = {\n\t\t\"/\": [2],\n\t\t\"/Collatz\": [3],\n\t\t\"/Martingale\": [4],\n\t\t\"/Python\": [5],\n\t\t\"/Test\": [6],\n\t\t\"/async5\": [7],\n\t\t\"/clone\": [8],\n\t\t\"/cube\": [9],\n\t\t\"/digitalannealing\": [10],\n\t\t\"/score\": [11]\n\t};\n\nexport const hooks = {\n\thandleError: (({ error }) => { console.error(error) }),\n\t\n\treroute: (() => {}),\n\ttransport: {}\n};\n\nexport const decoders = Object.fromEntries(Object.entries(hooks.transport).map(([k, v]) => [k, v.decode]));\n\nexport const hash = false;\n\nexport const decode = (type, value) => decoders[type](value);\n\nexport { default as root } from '../root.js';"],"file":"_app/immutable/entry/app.C4QIHwxW.js"}