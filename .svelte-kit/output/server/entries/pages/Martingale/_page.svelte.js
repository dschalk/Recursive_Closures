var e=Object.defineProperty,__name=(n,t)=>e(n,"name",{value:t,configurable:!0});import{e as n}from"../../../chunks/attributes.js";import"clsx";import{c as t,p as s}from"../../../chunks/index2.js";import{leftShift as a}from"mathjs";function _page(e,i){s();let o="";function clear(){o=""}__name(clear,"clear");const r=__name((()=>{}),"dF3x");function M(e){return __name((function go(n){return n===r?e:(e=n(e),go)}),"go")}__name(M,"M");var l=M([25,1,25,0]);function addLogMessage(e){o+=e+"\n"}function f1(e){addLogMessage(`m(dF3x) is ${JSON.stringify(l(r))}`);if(Math.floor(2*Math.random())){if(e[0]+=e[1],e[1]=1,e[3]+=1,!(e[3]<25))return addLogMessage(`Double ${JSON.stringify(l(r))}`),e;l(f1)}else{if(e[0]-=e[1],e[1]=a(e[1],1),e[1]>e[0])return void addLogMessage(`Fail ${JSON.stringify(l(r))}`);l(f1)}return e}__name(addLogMessage,"addLogMessage"),__name(f1,"f1"),l(f1),clear(),e.out+=`<div style="width: 80%; margin-left: 10%"><h1 style="text-align:center">Martingale Betting Strategy</h1> <p>"Instead of traditional recursion, where a function calls itself directly and builds up a call stack, you're calling m(f1) in a way that resets the closureâ€™s state rather than creating new stack frames." -- ChatGPT</p> <p><a href="https://medium.com/@pelicanlabs/a-curious-conclusion-from-the-martingale-betting-strategy-28dc297a5fee">The Martingale "Double Your Money" Betting Strategy</a> is, essentially, a system in which players double their bets each time they lose in an even-odds game of chance. Examples are calling "heads" or "tails" on fair flips of a fair coin, and betting on red or black on spins of a roulette wheel.</p> <p>When "Play" is clicked (below), line 3 of the function "f1" returns either 0 or 1 with equal probability. These numbers are equivalent to false and true in the test on line 4 ("if (result) ...").</p> <p>Clicing "Play" calls m(f1), where m = M([25,1,25,0]) and x is [25,1,25,0] in the resulting <a href="./">m-M(x) closure</a>. 'x' represents [starting amount, current bet, goal, number of wins], (beginning with [25,1,25,0]).</p> <button>Play</button> <button>Clear</button> <div><h2 class="svelte-6teu96">GAME OUTPUT</h2> <pre>${n(o)}</pre> <p>"********************************************"</p></div> <p>Players start with N dollars (m(dF3x)[0] === N), and stop if m(dF3x)[0] reaches 2N. Otherwise, players stop when they wouldn't have enough money to cover losing the next bet; i.e., when m(dF3x)[0] is less than m(dF3x)[1]. Here's the code:</p> <pre>    var log = console.log;\n    var dF3x = () => {};\n\n    function M(x) {\n        return function go(func) {\n            if (func === dF3x) return x;\n            x = func(x);\n            return go;\n        };\n    }\n\n    var m = M([25,1,25,0]); // x in the m(x)-M closure is [25,1,25,0]\n // The elements of x (above) represent a starting dollars, first bet, goal, and wins.\n\n\n    function f1(v) {\n        let result = Math.floor(Math.random() * 2);\n\n        if (result) {\n            v[0] += v[1];  // Increase stake by current bet\n            v[1] = 1;      // Reset bet to 1\n            v[3] += 1;     // Increment success counter\n\n            // Recursively continue if stake is less than goal\n            if (v[0] &lt; 50) {\n                m(f1);  // Continue this round of play\n            }\n        } else {\n            v[0] -= v[1];   // Subtract bet from stake (loss)\n            v[1] &lt;&lt;= 1;     // Double the bet (using bit shift)\n\n            // Check if the current bet exceeds stake; if not, continue\n            if (v[1] &lt;= v[0]) {\n                m(f1);  // Continue playing\n            }\n        }\n    }</pre> <p>Each time a player loses, the amount of the bet (which starts at $1) doubles. If the player wins a bet, all prior losses are recouped and $1 is gained. For example, if the bets were $1, $2, $4,and $8, winning $16 recoups the $(1+2+4+8) = $15, leaving one extra dollar.</p> <p>When m(dF3x)[3] === m(dF3x)[2], the player's money has doubled because each incremental increase in m(dF3x)[3] corresponds to an incremental increase in m(dF3x)[0]. The final value of x in the m-M(x) closure is m(dF3x) === [50,1,25,25].</p> <p>If v[3] is less than the starting amount, f1 calls m on itself to initiate another round of action. The semi-recursive function "f1" -- f1 repeatedly calls m(f1), causing f1 to execute on x in the closure --  executes on x until m(dF3x)[2] equals m(dF3x)[3] (Success), or m(dF3x)[0] is less than m(dF3x)[1] (Fail).</p> <p>Players fail most attempts to double their money. Lacking sufficient funds to cover a losing bet, they leave with whatever they still have. The amount they lose varies, but it's rarely everything they started with.</p> <h2 class="svelte-6teu96">A BILLION ATTEMPTS TO DOUBLE $50 IN AN m-M(x) CLOSURE</h2> <p>A file named test13.js is shown below. Entering "node test13" in my Linux desktop computer's simulated terminal starts a process that takes about 25 minutes to complete.  It uses only 6.2% of the available CPU potential, and a miniscule 60 megabytes of the 64 gigabytes of installed memory. There's obviously no danger of piling too many frames onto the stack.</p> <p>Here's test13.js:</p> <pre>var log = console.log;\nvar dF3x = () => {};\n\nfunction M(x) {\n    return function go(func) {\n        if (func === dF3x) return x;\n        x = func(x);\n        return go;\n    };\n}\n\nfunction gamble() {\n    let m = M([50, 1, 50, 0]);  // [stake, bet, goal, number successes] \n    let gain = 0;\n    let loss = 0;\n    let k = 0;\n\n    // Main loop\n    while (k &lt; 1000000000) {\n        k += 1;\n\n        // Place another bet.\n        m(f1);\n        \n        // Reset the closure state in preparation for another round.\n        m(() => [50, 1, 50, 0]);\n    }\n\n    // Log results after loop\n    log("k is", k);\n    log("gain is", gain);\n    log("loss is", loss);\n    log("percent deviation from equality is", ((gain - loss) / (gain + loss)) * 100, "%");\n\n    function f1(v) {\n        let result = Math.floor(Math.random() * 2);\n\n        if (result) {\n            gain += v[1];\n            v[0] += v[1];  // Increase stake by current bet\n            v[1] = 1;      // Reset bet to 1\n            v[3] += 1;     // Increment success counter\n\n            // Recursively continue if stake is less than goal\n            if (v[0] &lt; 100) {\n                m(f1);  // Continue playing\n            }\n        } else {\n            v[0] -= v[1];   // Subtract bet from stake (loss)\n            loss += v[1];   // Add to total loss\n            v[1] &lt;&lt;= 1;     // Double the bet (using bit shift)\n\n            // Check if the current bet exceeds stake; if not, continue\n            if (v[1] &lt;= v[0]) {\n                m(f1);  // Continue playing\n            }\n        }\n    }\n}\n\ngamble();</pre> <p style="margin: 3%">The result of calling gamble (above) five consecutive times, each time trying to double $50 a billion times, strongly suggests that repeated use of the Martingale betting strategy is a 50-50, break even proposition, similar to betting the same amount on coin flips thousands of times. I don't know how to prove it, but it seems self-evident that no pattern of changing the amounts of bets can possibly increase or decrease the odds of coming out ahead after repeatedly betting on fair flips of a fair coin.</p> <p>Here are the results:</p> <pre>\nk is 1000000000\ngain is 83168244121\nloss is 83169208725\npercent deviation from equality is -0.0005799078821370784 %\n\nk is 1000000000\ngain is 83171572605\nloss is 83170976285\npercent deviation from equality is 0.00035848915624969653 %\n\nk is 1000000000\ngain is 83168282625\nloss is 83170787098\npercent deviation from equality is -0.0015056432647907866 %\n\nk is 1000000000\ngain is 83169300078\nloss is 83170549366\npercent deviation from equality is -0.000751045527680717 %\n\nk is 1000000000\ngain is 83169558217\nloss is 83169526275\npercent deviation from equality is 0.000019202943251461886 %</pre> <br/><br/><br/></div>`,t()}__name(_page,"_page");export{_page as default};
//# sourceMappingURL=_page.svelte.js.map
