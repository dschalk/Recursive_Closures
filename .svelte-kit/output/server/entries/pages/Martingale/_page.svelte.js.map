{"version":3,"file":"_page.svelte.js","sources":["../../../../../../src/routes/Martingale/+page.svelte"],"sourcesContent":["\n<script>\n    import { leftShift } from \"mathjs\";\n    let output = ''; // Reactive variable to store log messages\n    function play () {\n        output = '';\n        m(() => [25, 1, 25, 0 ]);\n        m(f1);\n    }\n    function clear () {\n        output = '';\n    }\n\n    const dF3x = () => {};\n\n    function M(x) {\n        return function go(func) {\n            if (func === dF3x) return x;\n            x = func(x);\n            return go;\n        };\n    }\n\n    var m = M([25, 1, 25, 0]);\n\n    function addLogMessage(message) {\n        output += message + '\\n';\n    }\n\n    function f1(v) {\n            addLogMessage(`m(dF3x) is ${JSON.stringify(m(dF3x))}`);\n        const result = Math.floor(Math.random() * 2);\n        if (result) {\n            v[0] += v[1];\n            v[1] = 1;\n            v[3] += 1;\n            if (v[3] < 25) m(f1);\n            else {\n                addLogMessage(`Double ${JSON.stringify(m(dF3x))}`);\n                return v;\n            }\n        } else {\n            v[0] -= v[1];\n            v[1] = leftShift(v[1], 1);\n            if (v[1] > v[0]) {\n                addLogMessage(`Fail ${JSON.stringify(m(dF3x))}`);\n                return;\n            } else {\n                m(f1);\n            }\n        }\n        return v;\n    }\n\n    m(f1);\nvar spot = '${JSON.stringify(m(dF3x))}'\nvar stdCode = `    var log = console.log;\n    var dF3x = () => {};\n\n    function M(x) {\n        return function go(func) {\n            if (func === dF3x) return x;\n            x = func(x);\n            return go;\n        };\n    }\n\n    var m = M([25,1,25,0]); // x in the m(x)-M closure is [25,1,25,0]\n // The elements of x (above) represent a starting dollars, first bet, goal, and wins.\n\n\n    function f1(v) {\n        let result = Math.floor(Math.random() * 2);\n\n        if (result) {\n            v[0] += v[1];  // Increase stake by current bet\n            v[1] = 1;      // Reset bet to 1\n            v[3] += 1;     // Increment success counter\n\n            // Recursively continue if stake is less than goal\n            if (v[0] < 50) {\n                m(f1);  // Continue this round of play\n            }\n        } else {\n            v[0] -= v[1];   // Subtract bet from stake (loss)\n            v[1] <<= 1;     // Double the bet (using bit shift)\n\n            // Check if the current bet exceeds stake; if not, continue\n            if (v[1] <= v[0]) {\n                m(f1);  // Continue playing\n            }\n        }\n    }`\n\n\nvar gambleCode = `var log = console.log;\nvar dF3x = () => {};\n\nfunction M(x) {\n    return function go(func) {\n        if (func === dF3x) return x;\n        x = func(x);\n        return go;\n    };\n}\n\nfunction gamble() {\n    let m = M([50, 1, 50, 0]);  // [stake, bet, goal, number successes] \n    let gain = 0;\n    let loss = 0;\n    let k = 0;\n\n    // Main loop\n    while (k < 1000000000) {\n        k += 1;\n\n        // Place another bet.\n        m(f1);\n        \n        // Reset the closure state in preparation for another round.\n        m(() => [50, 1, 50, 0]);\n    }\n\n    // Log results after loop\n    log(\"k is\", k);\n    log(\"gain is\", gain);\n    log(\"loss is\", loss);\n    log(\"percent deviation from equality is\", ((gain - loss) / (gain + loss)) * 100, \"%\");\n\n    function f1(v) {\n        let result = Math.floor(Math.random() * 2);\n\n        if (result) {\n            gain += v[1];\n            v[0] += v[1];  // Increase stake by current bet\n            v[1] = 1;      // Reset bet to 1\n            v[3] += 1;     // Increment success counter\n\n            // Recursively continue if stake is less than goal\n            if (v[0] < 100) {\n                m(f1);  // Continue playing\n            }\n        } else {\n            v[0] -= v[1];   // Subtract bet from stake (loss)\n            loss += v[1];   // Add to total loss\n            v[1] <<= 1;     // Double the bet (using bit shift)\n\n            // Check if the current bet exceeds stake; if not, continue\n            if (v[1] <= v[0]) {\n                m(f1);  // Continue playing\n            }\n        }\n    }\n}\n\ngamble();`\n\nclear();\n\nvar runs = `\nk is 1000000000\ngain is 83168244121\nloss is 83169208725\npercent deviation from equality is -0.0005799078821370784 %\n\nk is 1000000000\ngain is 83171572605\nloss is 83170976285\npercent deviation from equality is 0.00035848915624969653 %\n\nk is 1000000000\ngain is 83168282625\nloss is 83170787098\npercent deviation from equality is -0.0015056432647907866 %\n\nk is 1000000000\ngain is 83169300078\nloss is 83170549366\npercent deviation from equality is -0.000751045527680717 %\n\nk is 1000000000\ngain is 83169558217\nloss is 83169526275\npercent deviation from equality is 0.000019202943251461886 %`;\n\nvar test13 = `var log = console.log;\nvar dF3x = () => {};\n\nfunction M(x) {\n    return function go(func) {\n        if (func === dF3x) return x;\n        x = func(x);\n        return go;\n    };\n}\n\nfunction gamble() {\n    let m = M([50, 1, 50, 0]);  // [stake, bet, goal, number successes] \n    let jumpUp = 0;\n    let jumpBack = 0;\n    let jumpZero = 0;\n    let gain = 0;\n    let loss = 0;\n    let k = 0;\n    let x = Date.now();\n    let q1 = true;\n    let q2 = false;\n    let q3 = false;\n    \n\n    // Main loop\n    while (k < 1000000000) {\n        k += 1;\n        \n        // if (gain === loss) even += 1;\n        // Reset the closure state in preparation for another round.\n        m(() => [50, 1, 50, 0]);\n        // Place another bet.\n        m(f1);\n    }\n\n    // Log results after loop\n    log(\"End\", (Date.now() - x) / 1000)\n    log(k, \"attempts\");\n    log(\"gain is\", gain);\n    log(\"loss is\", loss);\n    // log(\"Player jumped out of the red \",jumpUp, \"times\")\n    // log(\"Player fell back into the red \",jumpBack, \"times\")\n    log(\"jumpUp is\", jumpUp);\n    log(\"jumpBack is\", jumpBack);\n    log(\"percent deviation from equality is\", ((gain - loss) / (gain + loss)) * 100, \"%\");\n\n    function f1(v) {\n        let result = Math.floor(Math.random() * 2);\n        q1 = (gain > loss);\n        q2 = (loss > gain);\n\n        if (result) {      // Success\n            gain += v[1];\n\n            v[0] += v[1];  // Increase stake by current bet\n            v[1] = 1;      // Reset bet to 1\n            v[3] += 1;     // Increment success counter\n            // Recursively continue if stake is less than goal\n            if (q2 && (gain > loss)) jumpUp += 1;    \n            if (v[0] < 100) {\n                m(f1);  // Continue playing\n            }\n        } else {            // Failure\n            v[0] -= v[1];   // Subtract bet from stake (loss)\n            loss += v[1];   // Add to total loss\n            v[1] <<= 1;     // Double the bet (using bit shift)\n            if (q1 && (gain < loss)) jumpBack += 1;\n            // Check if the current bet exceeds stake; if not, continue\n            if (v[1] <= v[0]) {\n                m(f1);  // Continue playing\n            }\n        }\n    }\n}\n\ngamble();` ;\n\nvar chatGPT = `Yes, you're correct that something akin to tail recursion is happening,\nwhich prevents the stack from growing excessively and avoids a stack overflow, \neven though it doesn't meet the strict definition of \"tail recursion.\"\n\nWhat's Happening in test13:\n\nThe pattern in your M function with go and m(f1) effectively creates a loop-like\nbehavior using recursion. Here's why it doesn't cause stack overflow:\n\nThe function M(x) creates a closure where the state (x) is maintained and updated.\n\nInstead of traditional recursion, where a function calls itself directly and builds\nup a call stack, you're calling m(f1) in a way that resets the closure’s state rather\nthan creating new stack frames.\n\nEach recursive call reuses the existing closure without adding a new stack frame. This\nis why memory usage remains low, and you avoid stack overflow.\n\nEven though this isn't strict tail recursion (because the recursive call isn't the\nlast operation in all cases), it behaves similarly in the sense that it doesn't\naccumulate call stack frames. Instead, you're maintaining state via closures and\n reassigning the function call to keep the recursion going.\n\nKey Insights:\n\nTail-call optimization (TCO): This occurs when a recursive call is the final operation \nin a function, allowing the call stack to stay constant. While your code doesn't fully \nleverage TCO, it achieves something similar by managing state through closures\n\nNo stack overflow: Your m(f1) pattern ensures that the stack doesn't grow because it's \nnot adding new frames, it's more like iterative recursion—continuing to loop without a \ngrowing call stack.\n\nSo yes, your script is avoiding stack overflow in a way that resembles tail recursion \nbut is driven more by the closure and function-returning-function pattern. This is why \nit manages memory efficiently despite a high number of recursive calls.`\n\n</script>\n\n<style>\n    h2 {\n        text-align: center;\n    }\n</style>\n\n\n<div style = \"width: 80%; margin-left: 10%\">\n<h1 style=\"text-align:center\">Martingale Betting Strategy</h1>\n<p>\"Instead of traditional recursion, where a function calls itself directly and builds up a call stack, you're calling m(f1) in a way that resets the closure’s state rather than creating new stack frames.\" -- ChatGPT </p>\n<p> <a href = \"https://medium.com/@pelicanlabs/a-curious-conclusion-from-the-martingale-betting-strategy-28dc297a5fee\">The Martingale \"Double Your Money\" Betting Strategy</a> is, essentially, a system in which players double their bets each time they lose in an even-odds game of chance. Examples are calling \"heads\" or \"tails\" on fair flips of a fair coin, and betting on red or black on spins of a roulette wheel.</p>\n<p> When \"Play\" is clicked (below), line 3 of the function \"f1\" returns either 0 or 1 with equal probability. These numbers are equivalent to false and true in the test on line 4 (\"if (result) ...\"). </p>\n<p> Clicing \"Play\" calls m(f1), where m = M([25,1,25,0]) and x is [25,1,25,0] in the resulting <a href = \"./\">m-M(x) closure</a>. 'x' represents [starting amount, current bet, goal, number of wins], (beginning with [25,1,25,0]). </p>\n<button on:click = {play}>Play</button>\n<button on:click = {clear}>Clear</button>\n<div>\n    <h2>GAME OUTPUT</h2>\n    <pre>{output}</pre> <!-- The output will be displayed here -->\n    <p>\"********************************************\"</p>\n</div>\n\n<p> Players start with N dollars (m(dF3x)[0] === N), and stop if m(dF3x)[0] reaches 2N. Otherwise, players stop when they wouldn't have enough money to cover losing the next bet; i.e., when m(dF3x)[0] is less than m(dF3x)[1]. Here's the code:</p>\n<pre>{stdCode}</pre>\n<p> Each time a player loses, the amount of the bet (which starts at $1) doubles. If the player wins a bet, all prior losses are recouped and $1 is gained. For example, if the bets were $1, $2, $4,and $8, winning $16 recoups the $(1+2+4+8) = $15, leaving one extra dollar. </p>\n\n<p> When m(dF3x)[3] === m(dF3x)[2], the player's money has doubled because each incremental increase in m(dF3x)[3] corresponds to an incremental increase in m(dF3x)[0]. The final value of x in the m-M(x) closure is m(dF3x) === [50,1,25,25].</p>\n\n<p> If v[3] is less than the starting amount, f1 calls m on itself to initiate another round of action. The semi-recursive function \"f1\" -- f1 repeatedly calls m(f1), causing f1 to execute on x in the closure --  executes on x until m(dF3x)[2] equals m(dF3x)[3] (Success), or m(dF3x)[0] is less than m(dF3x)[1] (Fail).   \n</p>\n\n<p> Players fail most attempts to double their money. Lacking sufficient funds to cover a losing bet, they leave with whatever they still have. The amount they lose varies, but it's rarely everything they started with.</p>\n\n <h2> A BILLION ATTEMPTS TO DOUBLE $50 IN AN m-M(x) CLOSURE</h2>\n\n <p>A file named test13.js is shown below. Entering \"node test13\" in my Linux desktop computer's simulated terminal starts a process that takes about 25 minutes to complete.  It uses only 6.2% of the available CPU potential, and a miniscule 60 megabytes of the 64 gigabytes of installed memory. There's obviously no danger of piling too many frames onto the stack.  </p>\n<p> Here's test13.js: </p>\n<pre>{gambleCode}</pre>  \n<p style = \"margin: 3%\"> The result of calling gamble (above) five consecutive times, each time trying to double $50 a billion times, strongly suggests that repeated use of the Martingale betting strategy is a 50-50, break even proposition, similar to betting the same amount on coin flips thousands of times. I don't know how to prove it, but it seems self-evident that no pattern of changing the amounts of bets can possibly increase or decrease the odds of coming out ahead after repeatedly betting on fair flips of a fair coin.  </p>\n<p> Here are the results: </p>\n<pre>{runs}</pre>\n\n\n<br><br><br>\n</div>\n"],"names":["output","clear","__name","dF3x","M","x","go","func","m","addLogMessage","message","f1","v","JSON","stringify","Math","floor","random","leftShift"],"mappings":"+PAGQ,IAAAA,EAAS,GAMJ,SAAAC,QACID,EAAA,EACb,CAFSE,OAAAD,MAAA,eAIHE,EAAaD,QAAA,QAAT,iBAEDE,EAAEC,2BACSC,GAAGC,GACX,OAAAA,IAASJ,EAAaE,GAC1BA,EAAIE,EAAKF,GACFC,GACV,QACL,CANSJ,OAAAE,EAAA,SAQLI,EAAIJ,EAAG,CAAA,GAAI,EAAG,GAAI,aAEbK,cAAcC,GACnBV,GAAUU,EAAU,IACxB,UAESC,GAAGC,GACJH,4BAA4BI,KAAKC,UAAUN,EAAEL,OAE7C,GADWY,KAAKC,MAAsB,EAAhBD,KAAKE,UACnB,IACNL,EAAA,IAAMA,EAAE,GACVA,EAAE,GAAK,EACPA,EAAE,IAAM,IACJA,EAAE,GAAK,IAGA,OADPH,wBAAwBI,KAAKC,UAAUN,EAAEL,OAClCS,IAHMD,GAKrB,KAAO,CAGC,GAFFC,EAAA,IAAMA,EAAE,GACVA,EAAE,GAAKM,EAAUN,EAAE,GAAI,GACnBA,EAAE,GAAKA,EAAE,eACTH,sBAAsBI,KAAKC,UAAUN,EAAEL,OAGvCK,EAAEG,GAEV,CACO,OAAAC,CACX,CA3BSV,OAAAO,cAAA,iBAIAP,OAAAS,GAAA,MAyBTH,EAAEG,IAuGDV,+wCAkKKD"}