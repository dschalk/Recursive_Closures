{"version":3,"file":"_page.svelte.js","sources":["../../../../../../src/routes/digitalannealing/+page.svelte"],"sourcesContent":["\n<script>\n  // Initial state\n  var A = {\n    cities: [],\n    bestPath: [],\n    penultimatePath: [],\n    beforeDistance: 0,\n    afterDistance: 0,\n    improved: true,\n    step: 0,\n    lastChange: { start: -1, end: -1 }\n  };\n\n  import { onMount } from 'svelte';\n  const dF3x = Symbol('dF3x');\n\n  const M = (initialState) => {\n    let x = { ...initialState };\n    const go = (func) => {\n      if (func === dF3x) {\n        return x;\n      }\n      x = func(x);\n      return go;\n    };\n    return go;\n  };\n\n  // Update m initialization too\n  var m = M({\n    cities: [],\n    bestPath: [],\n    penultimatePath: [],\n    beforeDistance: 0,\n    afterDistance: 0,\n    improved: true,\n    step: 0,\n    lastChange: { start: -1, end: -1 }\n  });\n\n  let beforeCanvas;\n  let afterCanvas;\n\n  const generateCities = () => {\n    const newCities = Array.from({ length: 50 }, () => ({\n      x: Math.random() * 800,\n      y: Math.random() * 600,\n    }));\n\n    const newPath = Array.from({ length: newCities.length }, (_, i) => i);\n    const initialDistance = pathDistance(newPath, newCities);\n\n    m(v => ({\n      cities: newCities,\n      bestPath: newPath,\n      penultimatePath: newPath,\n      beforeDistance: initialDistance,\n      afterDistance: initialDistance,\n      improved: true,\n      step: 0,\n      lastChange: { start: -1, end: -1 }\n    }));\n    A = m(dF3x);\n    drawBefore(A.penultimatePath, A.lastChange);\n    drawAfter(A.cities, A.bestPath, A.lastChange);\n  };\n\n  const solveTSP = (m) => {\n    m((state) => {\n      if (!state.improved) return state;\n\n      const { bestPath, cities } = state;\n      const currentDistance = pathDistance(bestPath, cities);\n\n      for (let i = 1; i < bestPath.length - 1; i++) {\n        for (let j = i + 1; j < bestPath.length; j++) {\n          const newPath = [...bestPath];\n          const segment = newPath.slice(i, j + 1).reverse();\n          newPath.splice(i, segment.length, ...segment);\n\n          const newDistance = pathDistance(newPath, cities);\n          if (newDistance < currentDistance) {\n            return {\n              ...state,\n              bestPath: newPath,\n              penultimatePath: bestPath,\n              afterDistance: newDistance,\n              improved: true,\n              step: state.step + 1,\n              lastChange: { start: i, end: j },\n            };\n          }\n        }\n      }\n\n      return { ...state, improved: false, lastChange: { start: -1, end: -1 } };\n    });\n\n    A = m(dF3x);\n    console.log('Current state:', A);\n    drawBefore(A.penultimatePath, A.lastChange);\n    drawAfter(A.cities, A.bestPath, A.lastChange);\n  };\n\n  function pathDistance(path, cities) {\n    if (!path || !cities || path.length < 2 || cities.length < 2) return 0;\n\n    let totalDistance = 0;\n    try {\n      for (let i = 0; i < path.length - 1; i++) {\n        totalDistance += distance(cities[path[i]], cities[path[i + 1]]);\n      }\n      totalDistance += distance(cities[path[path.length - 1]], cities[path[0]]);\n    } catch (error) {\n      console.error('Error calculating path distance:', error);\n      return 0;\n    }\n    return totalDistance;\n  }\n\n  function distance(city1, city2) {\n    return Math.sqrt((city1.x - city2.x) ** 2 + (city1.y - city2.y) ** 2);\n  }\n\n  function drawBefore(path, lastChange) {\n    if (!beforeCanvas || !A.cities) return;\n\n    const ctx = beforeCanvas.getContext('2d');\n    ctx.clearRect(0, 0, beforeCanvas.width, beforeCanvas.height);\n\n    // Draw cities\n    ctx.fillStyle = 'blue';\n    A.cities.forEach((city) => {\n      ctx.beginPath();\n      ctx.arc(city.x, city.y, 5, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Draw the main path in red\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(A.cities[path[0]].x, A.cities[path[0]].y);\n    for (let i = 1; i < path.length; i++) {\n      ctx.lineTo(A.cities[path[i]].x, A.cities[path[i]].y);\n    }\n    ctx.stroke();\n\n    // Highlight the segment that will disappear (if any)\n    if (lastChange && lastChange.start >= 0 && lastChange.end >= 0) {\n      const { start, end } = lastChange;\n\n      ctx.strokeStyle = '#00FFFF'; // Bright cyan\n      ctx.lineWidth = 6; // Thicker line for emphasis\n      ctx.beginPath();\n      ctx.moveTo(A.cities[path[start]].x, A.cities[path[start]].y);\n      for (let i = start + 1; i <= end; i++) {\n        ctx.lineTo(A.cities[path[i]].x, A.cities[path[i]].y);\n      }\n      ctx.stroke();\n    }\n  }\n\n  function drawAfter(cities, path, lastChange) {\n    if (!afterCanvas) return;\n    const ctx = afterCanvas.getContext('2d');\n    ctx.clearRect(0, 0, afterCanvas.width, afterCanvas.height);\n\n    // Draw cities\n    ctx.fillStyle = 'blue';\n    cities.forEach(city => {\n      ctx.beginPath();\n      ctx.arc(city.x, city.y, 5, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Draw the main path in red\n    ctx.strokeStyle = 'red';\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(cities[path[0]].x, cities[path[0]].y);\n    path.forEach(index => {\n      ctx.lineTo(cities[index].x, cities[index].y);\n    });\n    ctx.lineTo(cities[path[0]].x, cities[path[0]].y); // Close the loop\n    ctx.stroke();\n\n    // Highlight the changed segments if they exist\n    if (lastChange && lastChange.start >= 0 && lastChange.end >= 0) {\n      const { start, end } = lastChange;\n\n      // Draw the original segment (before reversal) in bright cyan\n      ctx.strokeStyle = '#00FFFF'; // Bright cyan\n      ctx.lineWidth = 6; // Thicker line for emphasis\n      ctx.beginPath();\n      ctx.moveTo(cities[path[start]].x, cities[path[start]].y);\n      for (let i = start + 1; i <= end; i++) {\n        ctx.lineTo(cities[path[i]].x, cities[path[i]].y);\n      }\n      ctx.stroke();\n\n      // Draw the new segment (after reversal) in gold\n      ctx.strokeStyle = '#FFD700'; // Gold\n      ctx.lineWidth = 6; // Thicker line for emphasis\n      ctx.beginPath();\n      ctx.moveTo(cities[path[start]].x, cities[path[start]].y);\n      for (let i = end; i >= start; i--) {\n        ctx.lineTo(cities[path[i]].x, cities[path[i]].y);\n      }\n      ctx.stroke();\n    }\n  }\n\n  onMount(() => {\n    console.log('Component mounted');\n    m(v => ({\n      cities: [],\n      bestPath: [],\n      penultimatePath: [],\n      beforeDistance: 0,\n      afterDistance: 0,\n      improved: true,\n      step: 0\n    }));\n    A = m(dF3x);\n    console.log('Initial State:', A);\n  });\n</script>\n\n<h1>Traveling Salesman Problem</h1>\n<div style=\"display: flex; gap: 20px;\">\n  <div>\n    <h2>Before</h2>\n    <canvas bind:this={beforeCanvas} width=\"800\" height=\"600\"></canvas>\n    <p>Total Distance: {A?.beforeDistance ? A.beforeDistance.toFixed(2) : 'N/A'}</p>\n  </div>\n  <div>\n    <h2>After</h2>\n    <canvas bind:this={afterCanvas} width=\"800\" height=\"600\"></canvas>\n    <p>Total Distance: {A?.afterDistance ? A.afterDistance.toFixed(2) : 'N/A'}</p>\n  </div>\n</div>\n<button on:click={() => {\n  generateCities();\n}}>Generate Cities</button>\n<button on:click={() => {\n  if (A?.improved) {\n    solveTSP(m);\n  }\n}}>Solve TSP (Step-by-Step)</button>\n<button on:click={() => {\n  generateCities();\n}}>Reset</button>\n\n<p>Steps Taken: {A?.step}</p>\n<p>Improvement: {A?.beforeDistance && A?.afterDistance \n  ? `${(((A.beforeDistance - A.afterDistance) / A.beforeDistance) * 100).toFixed(2)}%` \n  : 'N/A'}</p>"],"names":["dF3x","Symbol","initialState","x","go","func","M","cities","bestPath","penultimatePath","beforeDistance","afterDistance","improved","step","lastChange","start","end","$.escape"],"mappings":"uNAeQ,MAAAA,EAAOC,OAAO,gBAETC,IACL,IAAAC,MAASD,GACP,MAAAE,UAAMC,GACNA,IAASL,EACJG,GAETA,EAAIE,EAAKF,GACFC,IALD,MAOD,OAAAA,IATF,IAaEE,CAAA,CACPC,OAAM,GACNC,SAAQ,GACRC,gBAAe,GACfC,eAAgB,EAChBC,cAAe,EACfC,UAAU,EACVC,KAAM,EACNC,YAAcC,OAAK,EAAMC,KAAO,+KAqMsC,sGAAKC,EAKP,4IAevDA,EArPP,0BAqPcA,EAGpB"}