var n=Object.defineProperty,__name=(t,a)=>n(t,"name",{value:a,configurable:!0});import{e as t}from"../../../chunks/attributes.js";import"clsx";import{c as a,p as e}from"../../../chunks/index2.js";function _page(n,r){e();var s=__name((()=>{}),"dF3x");function M(n){return __name((function go(t){return t===s?n:(n=idP(n).then((n=>t(n))),go)}),"go")}__name(M,"M");const i=M(3);async function idP(n){return await wait(5),n}function wait(n){return new Promise((t=>setTimeout(t,n)))}var o;async function squareP(n){return await wait(300),n*n}__name(idP,"idP"),__name(wait,"wait"),__name(squareP,"squareP");let u=__name((n=>async t=>(await wait(n),t)),"pause");async function hello(n){return o="Hello ",await wait(700),c="World",await wait(700),o=42,await wait(700),c=42,await wait(600),n}__name(hello,"hello");let d=__name((n=>async t=>(await wait(500),parseInt(n,10)+parseInt(t,10))),"addP"),l=__name((n=>async t=>(await wait(300),t/n)),"divP");o="A";var c="B",v="C",w="D";function restart(){o="A",c="B",v="C",w="D",i((()=>4))(d(3))(squareP)((n=>n-7))(s).then((n=>o=n)),i((n=>n/42))((n=>n+5))((n=>7*n))(u(600))(s).then((n=>c=n)),i(d(7))(Math.sqrt)((n=>6*n))(hello)(s).then((n=>v=n)),i(l(14))((n=>3*n))(d(5))((n=>3*n))(s).then((n=>w=n))}function*generatorFunction(){return yield"m(v=>v**3)",yield"m(dF3x)  // 3",yield"m(v=>v**3)(v=>v*2)(v=>v-12)",yield"m(dF3x)  // 42",yield"m(v=>v+7)(Math.sqrt)(dF3x)  // 7",""}__name(restart,"restart"),restart(),__name(generatorFunction,"generatorFunction");var p=generatorFunction();function cow(){var n=p.next().value;console.log("z is",n)}function handleEvent(n){59===n.keyCode&&cow()}__name(cow,"cow"),__name(handleEvent,"handleEvent"),cow(),console.log("Fuck you"),n.out+=`\x3c!----\x3esvelte:window on:keypress=${t(handleEvent)} /> <p>Using the modified version of M below, m can handle mixtures of synchronous and asynchronous arguments. idP(a) has no effect if a is a promise. Otherwise, idP transforms a into a promise. To see this in action, click "Restart" (below).</p> <pre>    var dF3x = () => {}; \n\n    function M (x) {\n        return function go (func){\n            if (func === dF3x) return x;\n            else x = idP(x).then(v => func(v));\n            return go;\n        };\n    };\n    \n    const m = M(3); </pre> <p id="yes">In the demonstration below, "m" is given mixtures of simple functions and promises.</p> <button data.sveltekit.reload="">Restart</button> <br/><br/> <span style="color: #FAF">          m(() => 4)(addP(3)) (squareP) (v => v-7)(dF3x).then(v => (A = v));\n=</span> <span style="font-weight: bold; color:red">${t(o)}</span>    <span>// x is changed to 4, then  (4+3)**2 - 7 = 42</span> <br/><br/> <span style="color:#FAF">         m(v => v/42)(v => v + 5)(v=>v*7)(pause(600))(dF3x).then(v => (B = v));\n= <span style="font-weight: bold; color:red">${t(c)}</span></span> <span>    //  (42/42)*6*7 = 42</span> <br/><br/> <span style="color:#FAF">         m(addP(7))(Math.sqrt)(v => v*6)(hello)(dF3x).then(a => (C = a));\n= <span style="font-weight: bold; color:red">${t(v)}</span></span> <span>    //  Math.sqrt(42 + 7) * 6 = 42</span> <br/><br/> <span style="color:#FAF">          m(divP(14))(v => v * 3)(addP(5))(v=> v * 3)(dF3x).then(v => (D = v)) = <span style="font-weight: bold; color:red">${t(w)}</span></span> <span>    //  ((42 / 14) * 3 + 5) * 3 = 42</span> <p>The asynchronous functions used above are in this list:</p> <pre>    function wait(ms) {\n      return new Promise(r => setTimeout(r, ms));\n    }\n    \n    async function squareP (x) {\n      await wait(300)\n      return x*x;\n    }\n    \n    let pause = t => async x => {\n      await wait(t)\n      return x;\n    }\n    \n    async function hello (x) {\n      await wait(1000)\n      A = "Hello "\n      await wait(700)\n      B = "World"\n      await wait(700)\n      A = 42\n      await wait(700)\n      B = 42\n      return x;\n    }\n    \n    let divPinverse = a => async b => {\n      await wait (300)\n      return a/b;\n    }\n    \n    let addP =  x => async y => {\n      await wait(300)\n      return parseInt(x,10) + parseInt(y,10);\n    }\n    \n    let doubleP = async y => {\n      await wait(600)\n      return 2 * parseInt(y,10) \n    }\n    \n    let multP = x => async y => {\n      await wait(600)\n      return x * y;\n    }\n    \n    let divP = a => async b => {\n      await wait (300)\n      return b/a;\n    }\n    \n    async function cubeP (x) {\n      await wait(600)\n      return x*x*x;\n    } </pre> <p>Here's the restart code:</p> <pre>    function restart () {\n      A = "A"\n      B = "B"\n      C = "C"\n      D = "D"\n    m(() => 4)(addP(3)) (squareP) (v => v-7)(dF3x).then(v => (A = v));\n      \n    m(v => v/42)(v => v + 5)(v=>v*7)(pause(600))(dF3x).then(v => (B = v));\n\n    m(addP(7))(Math.sqrt)(v => v*6)(hello)(dF3x).then(a => (C = a));\n\n    m(divP(14))(v => v * 3)(addP(5))(v=> v * 3)(dF3x).then(v => (D = v)); \n\n    }</pre> <br/><br/><br/> <br/><br/><br/>`,a()}__name(_page,"_page");export{_page as default};
//# sourceMappingURL=_page.svelte.js.map
